<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhcexo&#39;s blog</title>
  
  <subtitle>yet another fe blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhcexo.com/"/>
  <updated>2018-07-16T08:17:17.154Z</updated>
  <id>http://zhcexo.com/</id>
  
  <author>
    <name>zhcexo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flexbox 完全指南</title>
    <link href="http://zhcexo.com/2018/07/16/a-complete-guide-to-flexbox/"/>
    <id>http://zhcexo.com/2018/07/16/a-complete-guide-to-flexbox/</id>
    <published>2018-07-16T07:32:48.000Z</published>
    <updated>2018-07-16T08:17:17.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Flexbox Layout (Flexible Box) 模式用于提供一个更有效率的布局途径，让容器(container) 中的子元素(items) 在尺寸未知或者动态变化的时候，也能对齐和分配项目之间的空白，因为称作 flex (弹性)。</p><p>Flex 布局的主要思想是让容器能够改变里面项目的宽度/高度(或者顺序)，以便用最佳方式填充可用空间(大多用来适应各种不同的设备和屏幕尺寸)。flex 容器能让里面的子元素展示以适应可用空间，或者让它们收缩以防止溢出。</p><p>更重要的是，flexbox 的布局方式与常规布局(比如 block 就是基于垂直方向的，而 inline 是基于水平方向的)相比是方向无关的。虽然常规布局对页面来说可以做得很好，但它们缺乏灵活性去适应大型 APP 或复杂的 APP (特别当方向改变，窗口缩放，窗口拉伸，收缩等等)。</p><p><strong>注意：</strong> Flexbox 布局方式适合的是组件化的、小型的布局，如果是大型的布局，<a href="http://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">Grid 布局</a>更为适合。</p><h2 id="基础知识和相关术语"><a href="#基础知识和相关术语" class="headerlink" title="基础知识和相关术语"></a>基础知识和相关术语</h2><p>Flexbox 是一个完整的模式，而不是一个单独的属性，所以它包含了整套的属性。这些属性有的是设置到容器上的(父级元素，也就是 flex container)，有的是设置到子元素上的(子元素，也就是 flex items)。</p><p>如果说常规的布局是基于 block 和 inline 的流动方向，那么 flex 布局基于的就是 flex 的流动方向。下图指明了 flex 布局的规范。</p><p><img src="https://cdn.css-tricks.com/wp-content/uploads/2011/08/flexbox.png" alt="specification"></p><p>通常的，项目元素会基于主轴(从 main-start 到 main-end)或者交叉轴(从 cross-start 到 cross-end)陈列。</p><ul><li><strong>main axis 主轴</strong> - 主轴是 flex 容器里面的子元素陈列的基础轴，它不一定是水平方向的，它的方向依赖于 <code>flex-direction</code> 属性决定</li><li><strong>main-start | main-end</strong> - flex 子元素会依照 main-start 到 main-end 的方向来陈列</li><li><strong>main size</strong> - 一个 flex 元素的宽度或高度，取决于主轴方向，这两个值中的一个，就是 main size。flex 元素的 main size 属性是 <code>width</code> 或者 <code>height</code> 中的一个</li><li><strong>cross axis</strong> 交叉轴 - 垂直于主轴，它的方向取决于主轴的方向</li><li><strong>cross-start | cross-end</strong> - 容器的 flex 行里面填充的子元素，也会按照 cross-start 向着 cross-end 的方向摆放</li><li><strong>cross size</strong> - 一个 flex 子元素的宽度或高度，在交叉轴方向上，两个值中的一个</li></ul><h2 id="父级容器的属性-flex-container"><a href="#父级容器的属性-flex-container" class="headerlink" title="父级容器的属性(flex container)"></a>父级容器的属性(flex container)</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>用来定义一个 flex 容器，inline 级还是 block 级别取决于设置的值。它为 flex 容器的直接子元素定义了 flex 上下文。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; <span class="comment">/* or inline-flex */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><img src="https://css-tricks.com/wp-content/uploads/2013/04/flex-direction2.svg" alt="flex-direction"></p><p>这个属性确定主轴的方向，定义了子元素在父容器中的陈列。Flexbox 是一种单向布局理念，flex 子元素基本都是以水平行或者垂直列的方式呈现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>row</code> (默认值)：在 <code>ltr</code> 语言中是从左到右，<code>rtl</code> 语言中是从右到左</li><li><code>row-reverse</code>： 在 <code>ltr</code> 语言中是从右到左，<code>rtl</code> 语言中是从左到右</li><li><code>column</code>：跟 <code>row</code> 相同，但是是从上到下</li><li><code>column-reverse</code>：跟 <code>row-reverse</code> 相同，但是是从下到上</li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><img src="https://css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg" alt="flex-wrap"></p><p>默认的，flex 子元素会试着呈现在一行里面，改变这个值可以让子元素按需折行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>nowrap</code> (默认值)：所有的 flex 子元素都位于一行</li><li><code>wrap</code>：所有的 flex 子元素可以换行陈列于若干行，从上至下</li><li><code>wrap-reverse</code>：所有的 flex 子元素可以换行陈列于若干行，从下至上</li></ul><h3 id="flex-flow-给-flex-容器设置-flex-direction-和-flex-wrap-的缩写"><a href="#flex-flow-给-flex-容器设置-flex-direction-和-flex-wrap-的缩写" class="headerlink" title="flex-flow (给 flex 容器设置 flex-direction 和 flex-wrap 的缩写)"></a>flex-flow (给 flex 容器设置 flex-direction 和 flex-wrap 的缩写)</h3><p>这只是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的缩写方法而已，用于同时定义父容器的主轴交叉轴和是否折行，默认值是 <code>row nowrap</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;'flex-direction'&gt; || &lt;'flex-wrap'&gt;</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><img src="https://cdn.css-tricks.com/wp-content/uploads/2013/04/justify-content-2.svg" alt="justify-content"></p><p>此属性用于定义主轴的对齐方式。它用于分配剩余的空白空间(It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size.)。同时它也能控制子元素在超过一行时的对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.containter</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code> (默认值)：子元素从起始处开始呈现</li><li><code>flex-end</code>：子元素从末尾开始呈现</li><li><code>center</code>：子元素中间对齐</li><li><code>space-between</code>： 子元素均匀分布于行内，首元素位于行起始</li><li><code>space-around</code>：子元素及其周围空间都会均匀分布。值得注意的是，视觉上空白并不均匀，因为所有子元素都有两个边缘。首元素与父容器的边缘有一单位的空白，但与下一个子元素的边缘有两个单位的空白(也就是上一个元素的右空白与下一个元素的左空白叠加在一起)</li><li><code>space-evenly</code>：子元素均匀分布，每两个子元素之间的空白都是相等的</li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><img src="https://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg" alt="align-items"></p><p>用来定义 flex 子元素在交叉轴方向上，默认的陈列方式。可以看作是 <code>justify-content</code> 在交叉轴上的版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>：从 cross-start 的起始边缘开始呈现</li><li><code>flex-end</code>： 从 cross-end 的结束边缘开始呈现</li><li><code>center</code>：子元素垂直居中于交叉轴</li><li><code>baseline</code>：子元素按它们的 baseline 对齐</li><li><code>stretch</code> (默认值)：拉伸以填满容器(同时受到 min-width / max-width 的影响)</li></ul><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><img src="https://css-tricks.com/wp-content/uploads/2013/04/align-content.svg" alt="algin-content"></p><p>这个属性用于处理 flex 容器内行与行之间、在交叉轴上有多余空间时的对齐问题，如同 <code>justify-content</code> 在主轴上对子元素对齐的处理。</p><p><strong>注意：</strong> 这个属性在 flex 子元素只有一行的情况下是不生效的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>：行从父容器起始处呈现</li><li><code>flex-end</code>：行从父容器结束处呈现</li><li><code>center</code>：行与父容器中间对齐</li><li><code>space-between</code>：行之间均匀分布，第一行处于父容器起始，最后一行处理父容器结束处</li><li><code>space-around</code>：行之间均匀分布，并且每行的空白也是平均的</li><li><code>stretch</code> (默认值)：每行伸展以占据空白区域</li></ul><h2 id="子元素的属性-flex-items"><a href="#子元素的属性-flex-items" class="headerlink" title="子元素的属性(flex items)"></a>子元素的属性(flex items)</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><img src="https://css-tricks.com/wp-content/uploads/2013/04/order-2.svg" alt="order"></p><p>默认的，flex 子元素是按源码里的顺序来排列的。然而 <code>order</code> 属性可以控制它们在父容器中出现的顺序。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default is 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><img src="https://css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg" alt="flex-grow"></p><p>这个属性定义的是 flex 子元素按需增长的能力。它接受的值是无单的数字作为比例，它规定了子元素占据 flex 父容器内可用空间的量。</p><p>如果所有的子元素都把 <code>flex-grow</code> 设置为 1，那么父容器中剩余的空间将会平分给每一个子元素。如果其中一个子元素的值设置为 2，那么它将占据其他子元素 2 倍的空间 (或者试图占据 2 倍)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负数的值是非法的。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>这个属性定义的是 flex 子元素按需收缩的能力。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负数的值是非法的。</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>它定义的是子元素在分配到剩余空间之前的元素的默认尺寸。它的值可以是长度 (例如：20%，5rem 等等) 或者是关键字。<code>auto</code> 这个关键字意义是“参照宽度 width 或者高度 height 属性” (这是由 <code>main-size</code> 关键字暂代实现，直到被弃用为止)。<code>content</code> 这个关键字意义是“尺寸由子元素的内容来决定” - 这个关键字并没有被很好的支持，所以也不好测试，更不知道是 <code>max-content</code>、<code>min-content</code> 或 <code>fit-content</code> 中的哪个起的作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被设置为 0，那么内容周围的多余空白就没被考虑进去，如果设置为 <code>auto</code>，那么多余空白的分布，取决于它的 <code>flex-grow</code> 值。见下图：</p><p><img src="https://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" alt="flex-basis"></p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>这个属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 三个属性的简写方式，其中第二和第三个参数(也就是 <code>flex-shrink</code> 和 <code>flex-basis</code>)是可选的。默认值是 <code>0 1 auto</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用这个缩写的属性</strong> 而不是单独设置各种属性的值。因为缩写方法会智能地设置其他值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><img src="https://css-tricks.com/wp-content/uploads/2014/05/align-self.svg" alt="align-self"></p><p>这个属性允许单个的 flex 子元素的默认的对齐(或者被 <code>align-item</code> 声明过)被覆盖。</p><p>参看 <code>align-items</code> 解释，看可设置的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 对 flex 子元素无影响。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox - css-tricks.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;p&gt;Flexbox Layout (Flexible Box) 模式用于提供一个更有效率的布局途径，让容器(container)
      
    
    </summary>
    
    
      <category term="css" scheme="http://zhcexo.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>更新Ubuntu以及更新SS以支持新的加密方法</title>
    <link href="http://zhcexo.com/2018/07/06/ubuntu-update-and-ss-update/"/>
    <id>http://zhcexo.com/2018/07/06/ubuntu-update-and-ss-update/</id>
    <published>2018-07-06T02:48:19.000Z</published>
    <updated>2018-07-06T03:21:19.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>每次用 SSH 的方式登入服务器的时候，都会提示如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Ubuntu *.*.* LTS (GNU/Linux *.*.*-*-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line"></span><br><span class="line"> ……</span><br><span class="line"></span><br><span class="line">13 packages can be updated.</span><br><span class="line">10 updates are security updates.</span><br></pre></td></tr></table></figure><p>字面提示是有 13 个包可以升级，其中 10 个是安全更新。</p><p>事实上 Ubuntu 更新还是挺容易的，因为有 <code>apt-get</code>，不过更新完之后，还是会提示一些安全更新没做完，所以找了一下解决方案。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h4 id="命令说明："><a href="#命令说明：" class="headerlink" title="命令说明："></a>命令说明：</h4><ul><li><code>apt-get update</code> 从服务器更新可用的软件包<strong>列表</strong>。</li><li><code>apt-get upgrade</code> 根据列表，更新已安装的软件包。这个命令<strong>不会</strong>删除在列表中已经没有的软件包，<strong>也不会</strong>安装有依赖需求但尚未安装的软件包。</li><li><code>apt-get dist-upgrade</code> 根据列表，更新已安装的软件包。这个命令可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。</li></ul><p>所以使用上面三个命令完成更新之后，用 <code>reboot</code> 命令重启系统就行。<strong>需要注意的是，以上所有命令都需要在 root 权限下执行。</strong></p><p>更新完成之后，去启动 SS，然后就报错了，从没见过的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load libsodium failed with path None</span><br></pre></td></tr></table></figure><p>不清楚是更新的系统造成的，还是其他原因，反正 SS 不能用了。搜索了一下，发现用这个 lib 的话，SS 可以支持新的高效率一点的加密方式 <code>chacha20</code> 等等这些。</p><p>于是乎，装一下 <code>libsodium</code> 吧~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar xf LATEST.tar.gz &amp;&amp; cd libsodium-*.*.*</span><br><span class="line">./configure &amp;&amp; make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完毕之后，修改 SS 配置文件，把加密换成 <code>chacha20-ietf-poly1305</code>，启动 SS，没有任何报错，一切正常。</p><p>客户端也把加密方式修改成相应的，完成~~</p><h4 id="不用自己编译的安装方式（未验证）"><a href="#不用自己编译的安装方式（未验证）" class="headerlink" title="不用自己编译的安装方式（未验证）"></a>不用自己编译的安装方式（未验证）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:chris-lea/libsodium</span><br><span class="line">echo "deb http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo "deb-src http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list</span><br><span class="line">apt-get update &amp;&amp; apt-get install libsodium-dev</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ul><li><a href="https://liam0205.me/2015/06/27/ubuntu-server-packages-can-be-updated/" target="_blank" rel="noopener">升级 Ubuntu，解决登录时提示有软件包可以更新的问题</a></li><li><a href="https://blog.csdn.net/lengconglin/article/details/77655845" target="_blank" rel="noopener">Linux下安装libsodium,启用ss的chacha20高级加密</a></li><li><a href="https://gist.github.com/jonathanpmartins/2510f38abee1e65c6d92" target="_blank" rel="noopener">Install Libsodium on Ubuntu 14.04.3 LTS Trusty</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;每次用 SSH 的方式登入服务器的时候，都会提示如下信息：&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>让HTML Webpack Plugin根据多entry把html文件生成到指定目录中</title>
    <link href="http://zhcexo.com/2018/06/16/html-webpack-plugin-multiple-entries/"/>
    <id>http://zhcexo.com/2018/06/16/html-webpack-plugin-multiple-entries/</id>
    <published>2018-06-16T14:13:40.000Z</published>
    <updated>2018-07-06T03:23:53.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>项目里有需要处理一堆目录的 html 文件自动生成，并且生成到相应的目录中。与 html 文件相对应的样式 css 文件和脚本 js 文件，也要放到相应的目录中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">目录结构如下：</span><br><span class="line">- dist</span><br><span class="line">- src</span><br><span class="line">    |- a</span><br><span class="line">        `- index.js</span><br><span class="line">    |- b</span><br><span class="line">        `- index.js</span><br><span class="line">    |- c</span><br><span class="line">        `- index.js</span><br><span class="line">    `- tpl</span><br><span class="line">        `- index.html</span><br><span class="line">    </span><br><span class="line">希望得到的结果是，a，b，c 三个目录中的 index.js 都是入口文件，以 tpl 中的 index.html 为模板，</span><br><span class="line">经由 webpack 打包之后，在 dist 目录中生成 a，b，c 三个目录，</span><br><span class="line">并且每个目录中都存在 html，css，js 三个目录，里面存放相应生成的文件。</span><br><span class="line">生成如下的目录结构：</span><br><span class="line">- dist</span><br><span class="line">    |- a</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">    |- b</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">    `- c</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">- src</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>说到自动生成 html 文件，第一想法就是 <code>HtmlWebpackPlugin</code>，但是这个插件不支持 webpack 中类似于 <code>[name]</code> 这样的命名，所以想用 <code>[name]</code> 这样的命名方式变向成生文件夹的方法是行不通的。另外，每个条 <code>new HtmlWebpackPlugin()</code> 语句，只能生成一个页面，像我这样要大批量生成文件，是不太方便的。</p><p>因为要做到生成的文件，有对应的目录，所以在配置 webpack 的 entry 的时候，可以使用多入口方式。</p><p>大体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries: &#123;</span><br><span class="line">    a: <span class="string">'./a'</span>,</span><br><span class="line">    b: <span class="string">'./b'</span>,</span><br><span class="line">    c: <span class="string">'./c'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> entryHtmlPlugins = <span class="built_in">Object</span>.keys(entries).map(<span class="function"><span class="keyword">function</span>(<span class="params">entryName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        filename: entryName + <span class="string">'.html'</span>,</span><br><span class="line">        chunks: [entryName]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry: entries,</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">plugins: [</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">].concat(entryHtmlPlugins)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">HTML Webpack Plugin</a><br><a href="https://github.com/jantimon/html-webpack-plugin/issues/299" target="_blank" rel="noopener">Support multiple Webpack entries</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;项目里有需要处理一堆目录的 html 文件自动生成，并且生成到相应的目录中。与 html 文件相对应的样式 css 
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://zhcexo.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中为切片 append 元素之后 cap 变化的问题</title>
    <link href="http://zhcexo.com/2018/05/25/append-and-cap-in-golang/"/>
    <id>http://zhcexo.com/2018/05/25/append-and-cap-in-golang/</id>
    <published>2018-05-25T06:04:04.000Z</published>
    <updated>2018-05-25T06:29:39.034Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 Go 语言基础的时候，看到了 slice 切片这里，里面有个 append 方法，用于往 slice 里添加元素。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]</span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure><p>差一点就看看跳过了，不过最后一行的结果，<code>cap</code> 执行的结果显示，这个 <code>numbers</code> 切片的容量为 6。</p><p>如果是写其他的语言，比如 JavaScript，那么这个结果可能会跟 <code>length</code> 作类比从而产生“为什么容量不是 5”这种想法，毕竟我们只在 slice 里添加了 5 个元素。翻了一下官方的文档也没有解释，后来在 stackoverflow 上看到了别人的回答，大致总结如下：</p><blockquote><p>Go 会为你的 slice 提供比你需要的更多的容量，原因是在 slice 的底层，有个不可变动的（immutable）数组（array）在实际起作用。当你要为 slice 添加元素从而让切片的容量更大的时候，实际上是创建了一个新数组，把原来的切片元素和新添加的元素放到新的数组里，并把这个数组作为新 slice 的底层。如果你添加很多数据到 slice 里，就会反复去创建和复制这些数据，影响性能。所以运行时会分配比你期望的更多的容量到 slice，让复制数据这些操作变得不那么频繁。</p></blockquote><p>虽然原因找下来，感觉这个问题似乎不怎么重要，不过有人如果看到这里，跟我有同样的疑惑，也可以做个参照。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://stackoverflow.com/questions/38573983/capacity-of-slices-in-go" target="_blank" rel="noopener">https://stackoverflow.com/questions/38573983/capacity-of-slices-in-go</a></li><li><a href="https://stackoverflow.com/questions/38543825/appending-one-element-to-nil-slice-increases-capacity-by-two" target="_blank" rel="noopener">https://stackoverflow.com/questions/38543825/appending-one-element-to-nil-slice-increases-capacity-by-two</a></li><li><a href="https://blog.csdn.net/a_flying_bird/article/details/54428546" target="_blank" rel="noopener">Go-append使用方法及注意事项</a></li><li><a href="https://blog.csdn.net/zxhoo/article/details/70159926" target="_blank" rel="noopener">Go语言小知识之append()函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习 Go 语言基础的时候，看到了 slice 切片这里，里面有个 append 方法，用于往 slice 里添加元素。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="go" scheme="http://zhcexo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>记一次搭梯子的过程</title>
    <link href="http://zhcexo.com/2018/05/24/ladder/"/>
    <id>http://zhcexo.com/2018/05/24/ladder/</id>
    <published>2018-05-24T09:21:32.000Z</published>
    <updated>2018-05-24T09:54:42.402Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直用的 Japan 的线路，结果越来越不稳定，后来干脆变成不可用了，所以换了一家 VPS 换了一条线路，以此文章记录一下这次的过程，方便以后折腾。</p><p>服务器安装的是 <strong>ubuntu 18 LTS x64 版本</strong>，准备使用 55 和 kcp 当梯子。</p><h2 id="步骤：-以下步骤默认都是-root-下执行"><a href="#步骤：-以下步骤默认都是-root-下执行" class="headerlink" title="步骤：(以下步骤默认都是 root 下执行)"></a>步骤：(以下步骤默认都是 root 下执行)</h2><h3 id="1-安装-python-pip-和-55"><a href="#1-安装-python-pip-和-55" class="headerlink" title="1. 安装 python-pip 和 55"></a>1. 安装 python-pip 和 55</h3><p>使用两个命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><p>执行第二个命令如果报错，例如 <code>ImportError: No module named setuptools</code>，只需要再安装 setuptools 即可。</p><p>先查看自己服务器的 Python 版本：</p><blockquote><ol><li>在终端上输入 python，进入 python shell</li><li>输入 help() 查看 python 版本</li><li>查看完毕后，输入 exit() 退出 python shell</li></ol></blockquote><p>接下来安装 setuptools：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python3.4</span><br></pre></td></tr></table></figure><h3 id="2-配置和启用-55"><a href="#2-配置和启用-55" class="headerlink" title="2. 配置和启用 55"></a>2. 配置和启用 55</h3><p>安装完之后，在 <code>/etc/</code> 目录下创建配置文件，命名为 <code>shadowsocks.json</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,             <span class="comment">// your server ip goes here</span></span><br><span class="line">    <span class="string">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"**********"</span>,        <span class="comment">// your ss password goes here</span></span><br><span class="line">    <span class="string">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-gcm"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动和停止 55 的方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start      # 这是后台启动的方式</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop       # 这是对应的停止的方式</span><br></pre></td></tr></table></figure><h3 id="3-安装-kcptun"><a href="#3-安装-kcptun" class="headerlink" title="3. 安装 kcptun"></a>3. 安装 kcptun</h3><p>直接访问项目地址吧，安装过程不说了，<a href="https://github.com/kuoruan/shell-scripts" target="_blank" rel="noopener">https://github.com/kuoruan/shell-scripts</a>。</p><p>安装过程中可能会提示 <code>iptables</code> 相关的错误，原因是 <code>iptables</code> 在 centos 和 ubuntu 上有差异。脚本似乎是针对 centos 写的，不过无所谓，脚本里面已经提示了自己去解决 <code>iptables</code> 问题，但直接按提示去解决会出错。</p><p>解决办法无外乎两步：首先添加相应规则到 <code>iptables</code>，然后重启 <code>iptables</code> 服务。</p><p>添加 <code>iptables</code> 配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p udp --dport 29900 -j ACCEPT        # 29900 换成你自己的</span><br></pre></td></tr></table></figure></p><p>保存 <code>iptables</code> 的配置（ubuntu 下）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save</span><br></pre></td></tr></table></figure></p><p>重启 <code>iptables</code>，因为 ubuntu 用的是 <code>ufw</code> 作为 <code>iptables</code> 的前端，所以使用如下命令重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ufw restart</span><br></pre></td></tr></table></figure></p><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><p>在配置 kcptun 的时候，加速的 IP 填写外网的 IP，如果填本地 IP（127.0.0.1 或者 0.0.0.0）都会出来 <code>dial tcp 127.0.0.1:8388: connect: connection refused</code> 这种错误。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><p><a href="https://blog.kuoruan.com/110.html" target="_blank" rel="noopener">https://blog.kuoruan.com/110.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直用的 Japan 的线路，结果越来越不稳定，后来干脆变成不可用了，所以换了一家 VPS 换了一条线路，以此文章记录一下这次的过程，方便以后折腾。&lt;/p&gt;
&lt;p&gt;服务器安装的是 &lt;strong&gt;ubuntu 18 LTS x64 版本&lt;/strong&gt;，准备使用 55
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>在 VSCODE 中安装 Go 语言相关支持</title>
    <link href="http://zhcexo.com/2018/05/21/go-tools-in-vscode/"/>
    <id>http://zhcexo.com/2018/05/21/go-tools-in-vscode/</id>
    <published>2018-05-21T01:58:03.000Z</published>
    <updated>2018-05-21T02:11:44.133Z</updated>
    
    <content type="html"><![CDATA[<p>写好 Go 文件，用 VSCode 打开之后，右下角会提示缺少 Go 相关的支持，然后会有两个按钮 <code>Install</code> 和 <code>Show</code>。<code>Install</code> 是自动安装这些支持，<code>Show</code> 是显示缺了些什么。但实际情况是，点了 <code>Install</code> 之后，控制台一堆报错并且安装失败。</p><p>点击 <code>Install</code> 或者 <code>Show</code>，控制台里已经显示缺少如下工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">github.com/ramya-rao-a/go-outline</span><br><span class="line">github.com/acroca/go-symbols</span><br><span class="line">golang.org/x/tools/cmd/guru</span><br><span class="line">golang.org/x/tools/cmd/gorename</span><br><span class="line">github.com/rogpeppe/godef</span><br><span class="line">github.com/sqs/goreturns</span><br><span class="line">github.com/golang/lint/golint</span><br><span class="line">github.com/derekparker/delve/cmd/dlv</span><br></pre></td></tr></table></figure><p>然后用 <code>go install</code> 或者 <code>go get -v</code> 都安装不成功。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>打开 Go 的安装目录</li><li>进入安装目录下的 <code>src</code> 目录，新建 <code>golang.org</code> 目录，在此目录下继续新建 <code>x</code> 目录</li><li>进入 <code>安装目录/golang.org/x</code> 目录，执行以下两个命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/golang/tools.git</span><br><span class="line">git clone https://github.com/golang/lint.git</span><br></pre></td></tr></table></figure><p>第一个安装除 <code>go-lint</code> 之外其他工具的支持，第二个安装 <code>go-lint</code> 支持。</p><p>以上步骤都处理完之后，就可以用 <code>go get ***</code> 和 <code>go install ***</code> 这种方式把缺的工具都装好。安装之后重启 VScode 即使用 Go 语言相关支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写好 Go 文件，用 VSCode 打开之后，右下角会提示缺少 Go 相关的支持，然后会有两个按钮 &lt;code&gt;Install&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt;。&lt;code&gt;Install&lt;/code&gt; 是自动安装这些支持，&lt;code&gt;Show&lt;/cod
      
    
    </summary>
    
    
      <category term="go" scheme="http://zhcexo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>同一页面运行wepback不同实例出现冲突的解决办法</title>
    <link href="http://zhcexo.com/2018/04/18/webpack-multiple-instance-on-the-same-page/"/>
    <id>http://zhcexo.com/2018/04/18/webpack-multiple-instance-on-the-same-page/</id>
    <published>2018-04-18T03:03:00.000Z</published>
    <updated>2018-07-06T03:23:53.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>对于同一个页面功能由不同的同事开发，都用到了 <code>webpack</code> 以及 <code>CommonsChunkPlugin</code>，最后把打包出来的代码，整合到一起的时候，冲突了。</p><h3 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h3><p>各自用 <code>webpack</code> 打包代码没有问题，但是加载到页面上时，代码报错且错误难以定位。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在 <code>webpack</code> 的配置选项里使用 <code>output.jsonpFunction</code>。</p><p>看一下文档里说的：</p><blockquote><p>output.jsonpFunction<br><code>string</code><br>仅用在输出目标为 web，且使用 jsonp 的方式按需加载代码块时。<br>一个命名的 JSONP 函数用于异步加载代码块或者把多个初始化代码块合并到一起时使用（如 CommonsChunkPlugin, AggressiveSplittingPlugin）。<br>当同一个页面上有多个 webpack 实例（源于不同的编译），需要修改这个函数名。<br>如果使用了 <code>output.library</code> 选项，那么这个 <code>library</code> 的命名会自动附加上。</p></blockquote><p>事实上 webpack 并不在全局命名空间下运行，但是 <code>CommonsChunkPlugin</code> 这样的插件会使用异步 JSONP 的方法按需加载代码块。插件会注册一个全局的函数叫 <code>window.webpackJsonp</code>，所以同一个页面上运行多个源自不同 webpack 打包出来的代码时，可能会引起冲突。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://webpack.js.org/configuration/output/#output-jsonpfunction" target="_blank" rel="noopener">webpack - configuration - output - jsonpfunction</a></p><p><a href="https://medium.com/@cliffers/how-to-run-multiple-webpack-instances-on-the-same-page-and-avoid-any-conflicts-4e2fe0f016d1" target="_blank" rel="noopener">How to run multiple webpack instances on the same page…and avoid any conflicts</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;对于同一个页面功能由不同的同事开发，都用到了 &lt;code&gt;webpack&lt;/code&gt; 以及 &lt;code&gt;Commo
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://zhcexo.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>常用 git 命令备忘</title>
    <link href="http://zhcexo.com/2018/03/23/git-cheat-sheet/"/>
    <id>http://zhcexo.com/2018/03/23/git-cheat-sheet/</id>
    <published>2018-03-23T03:02:43.000Z</published>
    <updated>2018-03-23T03:10:47.348Z</updated>
    
    <content type="html"><![CDATA[<p>导出项目文件</p><p><code>git archive --format zip -o filename.zip HEAD</code></p><p>修剪远程分支</p><p><code>git remote prune origin</code></p><p>显示本地分支与远程分支跟踪关系</p><p><code>git branch -vv</code></p><p>重命名本地分支</p><p><code>git branch -m oldname newname</code></p><p>本地分支与远程分支建立关系</p><p><code>git branch --set-upstream-to=origin/&lt;branch&gt; &lt;cur branch&gt;</code></p><p>强制覆盖本地文件的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git reset --hard origin/master 或</span><br><span class="line">git reset --hard origin/develop 依此类推，使用想用的分支</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导出项目文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git archive --format zip -o filename.zip HEAD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修剪远程分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote prune origin&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="git" scheme="http://zhcexo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>在 PhpStorm 中集成 git bash</title>
    <link href="http://zhcexo.com/2018/03/22/phpstorm-with-git-bash/"/>
    <id>http://zhcexo.com/2018/03/22/phpstorm-with-git-bash/</id>
    <published>2018-03-22T10:12:34.000Z</published>
    <updated>2018-03-23T03:33:09.173Z</updated>
    
    <content type="html"><![CDATA[<p>直接看图，注意后面的参数 <code>-login -i</code> 不能反了。</p><p><img src="http://of723n9da.bkt.clouddn.com/2016-10-17_220547.jpg" alt="git bash in phpstorm"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接看图，注意后面的参数 &lt;code&gt;-login -i&lt;/code&gt; 不能反了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://of723n9da.bkt.clouddn.com/2016-10-17_220547.jpg&quot; alt=&quot;git bash in phpst
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://zhcexo.com/tags/Tools/"/>
    
  </entry>
  
</feed>
