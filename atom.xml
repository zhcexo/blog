<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhcexo&#39;s blog</title>
  
  <subtitle>yet another fe blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhcexo.com/"/>
  <updated>2019-03-21T11:54:49.041Z</updated>
  <id>http://zhcexo.com/</id>
  
  <author>
    <name>zhcexo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习Vuex源码前的准备——模块及加载实现</title>
    <link href="http://zhcexo.com/2019/03/21/module-import-export/"/>
    <id>http://zhcexo.com/2019/03/21/module-import-export/</id>
    <published>2019-03-21T09:12:23.000Z</published>
    <updated>2019-03-21T11:54:49.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块都只能在运行时确定这些东西。</p><p><strong>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</strong></p><p>由于 ES6 模块是编译时加载，使用静态分析成为可能。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块<strong>自动采用严格模式</strong>，不管有没有在模块的头部加上 <code>&quot;use strict&quot;</code>。</p><p>严格模式的限制：</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 <code>with</code> 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 的八进制数，否则报错</li><li>不能删除变量 <code>delete prop</code>，会报错，只能删除属性 <code>delete global[prop]</code></li><li><code>eval</code> 不会在它的外层作用域引入变量</li><li><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</li><li><code>arguments</code> 不会自动反映函数参数的变化</li><li>不能使用 <code>arguments.callee</code></li><li>不能使用 <code>arguments.caller</code></li><li>禁止 <code>this</code> 指向全局变量</li><li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li><li>增加了保留字（比如 <code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><p>其中，尤其需要注意 <code>this</code> 的限制。ES6 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code>。</p><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p><code>export</code> 命令用于规定模块的对外接口。<strong>一个模块就是一个独立的文件</strong>，该文件内部的所有变量，外部无法获取 。如果希望外部能够读取模块内部的某个变量，必须使用 <code>export</code> 关键字输出该变量。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 as 关键字重命名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">    v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">    v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意： <code>export</code> 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br></pre></td></tr></table></figure><p>上面的代码报错是因为没有提供对外的接口。第一种直接输出 1，第二种通过变量 <code>m</code> 还是直接输出的 1。<code>1</code> 只是一个值，不是接口。正确的写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure><p>上面的三种写法都规定了对外接口 <code>m</code>，其他的脚本可以通过这个接口取到值 <code>1</code>，所以三种写法都对。<strong>它们的实质是，在接口与模块内部变量之间，建立了一一对应的关系。</strong></p><p><code>function</code> 和 <code>class</code> 的输出，也必须遵守这样的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p>另外，<code>export</code> 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。例如下面的代码，输出的变量是 <code>foo</code>，值为 <code>bar</code>，但是 500ms 之后变成了 <code>baz</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用 <code>export</code> 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 <code>import</code> 命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"><span class="comment">// or 重命名</span></span><br><span class="line"><span class="keyword">import</span> &#123;lastName <span class="keyword">as</span> surname&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContext = firstName + <span class="string">''</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>import</code> 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许加载模块的脚本里，改写接口。但如果加载的变量是个对象，改成对象的属性是允许的。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span>;</span><br><span class="line"></span><br><span class="line">a = &#123;&#125;;             <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'hello'</span>;    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>注意，<code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为 <code>import</code> 的执行早于 <code>foo</code> 的调用。这种行为的本质是，<code>import</code> 命令是编译阶段执行的，在代码运行之前。</p><p>也正因为 <code>import</code> 是静态执行，所以不能使用表达式和变量——这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="string">'f'</span> + <span class="string">'oo'</span>&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和 <code>if</code> 结构。在静态分析阶段，这些语法都是没法得到值的。</p><p>最后，<strong><code>import</code> 语句会执行所加载的模块</strong>，因此可以有下面的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码仅仅执行 <code>lodash</code> 模块，但是不输入任何值。</p><p>如果多次重复执行同一句 <code>import</code> 语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例 1</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例 2</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>目前通过 Babel 转码，CommonJS 的 <code>require</code> 和 ES6 模块的 <code>import</code> 命令可以写在同一个模块里，<strong>但最好不要这样做</strong>。因为 <code>import</code> 在<strong>静态解析阶段</strong>执行，所以<strong>它是一个模块之中最早执行的</strong>。</p><p>下面的代码可能不会得到预期结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.symbol'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/modules/es6.promise'</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加载 <code>circle.js</code> 这个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;area, circumference&#125; <span class="keyword">from</span> <span class="string">'./circle.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象（上例是 <code>circle</code>），应该是可以静态分析的，所以不允许运行时改变，以下会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a><code>export default</code> 命令</h2><p>从上面的例子可以看出，使用 <code>import</code> 命令时，需要知道所要加载的变量名或者函数名，否则无法加载。为了方便，可以用 <code>export default</code> 命令，为模块指定默认输出。</p><p>本质上，<code>export default</code> 就是输出一个叫 <code>default</code> 的变量或方法，然后系统允许你给它取任意名字。但它后面不能跟变量声明语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组----------------------------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组----------------------------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三组----------------------------</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四组----------------------------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第五组---------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于 export default add</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> foo&#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于 import foo from 'modules'</span></span><br></pre></td></tr></table></figure><p>上面的第一组，<code>foo</code> 函数的函数名 <code>foo</code>，<strong>在模块外面是无效的</strong>，<strong>加载的时候视同匿名函数</strong>。</p><p>上面的第二组，使用 <code>export default</code> 时，对应的 <code>import</code> 语句不需要使用大括号。</p><p>上面的第三组，不使用 <code>export default</code>，对应的 <code>import</code> 语句需要使用大括号。</p><p>上面的第四组，不能在 <code>export default</code> 后面使用变量声明语句。</p><p>上面的第五组，体现 <code>export default</code> 就是输出一个叫 <code>default</code> 的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>上面的代码，后一句报错是因为没有指定对外的接口，而前一句的对外接口是 <code>default</code>。</p><p>输出一个类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a><code>export</code> 与 <code>import</code> 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一模块，<code>import</code> 语句可以与 <code>export</code> 语句写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo, bar&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>export</code> 和 <code>import</code> 语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code> 和 <code>bar</code> 实际上<strong>并没有被导入当前模块</strong>，只是相当于对外转发了两个接口，导致<strong>当前模块不能直接使用 <code>foo</code> 和 <code>bar</code></strong>。</p><h2 id="浏览器中的模块加载"><a href="#浏览器中的模块加载" class="headerlink" title="浏览器中的模块加载"></a>浏览器中的模块加载</h2><h3 id="浏览器中加载"><a href="#浏览器中加载" class="headerlink" title="浏览器中加载"></a>浏览器中加载</h3><p>浏览器中加载脚本，一般是用下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>defer</code> 与 <code>async</code> 的区别是：<code>defer</code> 要等整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code> 是一旦下载完，渲染引擎就会中断渲染，执行这个脚本后，再继续渲染。一句话，<code>defer</code> 是<strong>渲染完再执行</strong>，<code>async</code> 是<strong>下载完就执行</strong>。另外，如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载，而多个 <code>async</code> 脚本是不保证加载顺序的。</p><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"path/to/module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上 <code>type=&quot;module&quot;</code> 之后，浏览器就知道这是一个 ES6 模块。浏览器对带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>，都是异步加载，不会造成浏览器堵塞，等整个页面渲染完后，再执行脚本，相当于打开了 <code>defer</code> 属性。</p><p>如果网页中有多个 <code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p><p>但如果此时 <code>&lt;script&gt;</code> 的 <code>async</code> 属性也打开了，这时只要加载完成，渲染引擎就会中断渲染立即执行脚本，执行完后再恢复渲染。一旦用了 <code>async</code> 属性，<code>&lt;script&gt;</code> 就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p><h2 id="ES6-与-CommonJS-模块的差异"><a href="#ES6-与-CommonJS-模块的差异" class="headerlink" title="ES6 与 CommonJS 模块的差异"></a>ES6 与 CommonJS 模块的差异</h2><p>两个重大差异：</p><ul><li>CommonJS 的模块输出的是一个<strong>值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</li><li>CommonJS 的模块是<strong>运行时加载</strong>，ES6 的模块是<strong>编译时输出接口</strong>。</li></ul><p>另一个差异是因为 CommonJS 加载的是一个对象（即 <code>module.exports</code> 属性），该对象只有在<strong>脚本运行完</strong>才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码<strong>静态解析阶段就会生成</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现</a></p><p>本文基本是上面链接的笔记和再整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://zhcexo.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习Vuex源码前的准备——变量的解构赋值</title>
    <link href="http://zhcexo.com/2019/03/21/destructuring/"/>
    <id>http://zhcexo.com/2019/03/21/destructuring/</id>
    <published>2019-03-21T02:05:56.000Z</published>
    <updated>2019-03-21T06:08:35.774Z</updated>
    
    <content type="html"><![CDATA[<p>继续第二章，变量的解构赋值。</p><h2 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值"></a>什么是解构赋值</h2><p>ES6 允许按照一定的<strong>模式</strong>，<strong>从数组和对象中提取值</strong>，这种方式被称为解构（Destructuring）。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>以前为变量赋值，只能直接指定值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>但是解构赋值允许这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>意义就跟上面一样了，为 <code>a</code>，<code>b</code>，<code>c</code> 分别赋值。</p><p>本质上，这种写法属于<strong>“模式匹配”</strong>，只要等号两边的模式相同，左边的变量就会被赋予相应的值。以下是更多例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];</span><br><span class="line">third   <span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x   <span class="comment">// 1</span></span><br><span class="line">y   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head    <span class="comment">// 1</span></span><br><span class="line">tail    <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x   <span class="comment">// 'a'</span></span><br><span class="line">y   <span class="comment">// undefined</span></span><br><span class="line">z   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于 <code>undefined</code>。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x   <span class="comment">// 1</span></span><br><span class="line">y   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a   <span class="comment">// 1</span></span><br><span class="line">b   <span class="comment">// 2</span></span><br><span class="line">d   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>如果等号的右边不是数组（或者严格的说，不是可遍历的结构），那么将会报错。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。但要注意的是，ES6 内部使用严格相等运算符号（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于 <code>undefined</code>，默认值才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]</span><br><span class="line">x   <span class="comment">// 'a'</span></span><br><span class="line">y   <span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>];</span><br><span class="line">x   <span class="comment">// 'a'</span></span><br><span class="line">y   <span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x   <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，即只有在用到的时候，才会求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// f() 不会执行，所以 x 能获得值，是 1、</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [];</span><br><span class="line"><span class="comment">// 解构的右边是 undefined，x 取不到值，那么默认赋值开始，f() 执行</span></span><br><span class="line"><span class="comment">// 此时 x 的值为 f() 的返回值，此例中是 undefined （无返回值）</span></span><br></pre></td></tr></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构赋值和数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo, bar&#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line">foo <span class="comment">// 'aaa'</span></span><br><span class="line">bar <span class="comment">// 'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;bar, foo&#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line">foo <span class="comment">// 'aaa'</span></span><br><span class="line">bar <span class="comment">// 'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;baz&#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果变量名与属性名不一致，必须写成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: baz&#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line">foo <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br><span class="line">baz <span class="comment">// 'aaa'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">first</span>: f, <span class="attr">last</span>: l&#125; = obj;</span><br><span class="line">f   <span class="comment">// 'hello'</span></span><br><span class="line">l   <span class="comment">// 'world'</span></span><br><span class="line">first   <span class="comment">// Uncaught ReferenceError: first is not defined</span></span><br><span class="line">last    <span class="comment">// Uncaught ReferenceError: last is not defined</span></span><br></pre></td></tr></table></figure><p>实际上说明，对像的解构赋值是下面形式的简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar&#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。<strong>真正被赋值的是后者，而不是前者。</strong></p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      y: <span class="string">'World'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;y&#125;]&#125; = obj;</span><br><span class="line">x   <span class="comment">// 'Hello'</span></span><br><span class="line">y   <span class="comment">// 'World'</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>p</code> 是模式，不是变量，所以 <code>p</code> 不会被赋值，如果 <code>p</code> 也要作为变量赋值，要写成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续上</span></span><br><span class="line"><span class="keyword">let</span> &#123;p, <span class="attr">p</span>: [x, &#123;y&#125;]&#125; = obj;</span><br><span class="line">p   <span class="comment">// ['Hello', &#123;y: 'World'&#125;]</span></span><br><span class="line">x   <span class="comment">// 'Hello'</span></span><br><span class="line">y   <span class="comment">// 'World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;loc, <span class="attr">loc</span>: &#123;start&#125;, <span class="attr">loc</span>: &#123;<span class="attr">start</span>: &#123;line, column&#125;&#125;&#125; = node</span><br><span class="line">loc     <span class="comment">// Object &#123;start: &#123;line: 1, column: 5&#125;&#125;</span></span><br><span class="line">start   <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br><span class="line">line    <span class="comment">// 1</span></span><br><span class="line">column  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>同数组解构的默认值一样，<strong>对象的属性值严格等于 <code>undefined</code> 时默认值才会生效</strong>。如果解构失败，变量的值等于 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x   <span class="comment">// 1</span></span><br><span class="line">y   <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x   <span class="comment">// error，要记住，x 是模式，不赋值</span></span><br><span class="line">y   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y   <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span>&#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// 'Something went wrong'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的属性值严格等于 undefined 时默认值才会生效</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构失败的例子</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。如果要将一个已经声明的变量用于解构赋值，也要小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot destructure property `bar` of 'undefined' or 'null'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的解构相当于下面的代码，所以才会报错</span></span><br><span class="line"><span class="keyword">let</span> _tmp = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line">_tmp.foo.bar</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'bar' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure><p>上面的写法会报错，因为 JS 引擎会将 <code>{x}</code> 解释成一个代码块，从而发生语法错误。<strong>只有不将花括号写在行首，避免 JS 将它解释成代码块，才能解决问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>解构赋值允许等号左边的模式之中，不放置任何变量名，因为可以写出非常古怪的表达式，它们没有意义，但是语法合法，可以执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>对象的解构赋值，可以很方便的将现有对象的方法，赋值到某个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;log, sin, cos&#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>由于数组的本质也是对象，因此可以对数组进行对象的解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: first, [arr.length <span class="number">-1</span>]: last&#125; = arr;</span><br><span class="line">first   <span class="comment">// 1</span></span><br><span class="line">last    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>对字符串进行解构赋值时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a  <span class="comment">// 'h'</span></span><br><span class="line">b  <span class="comment">// 'e'</span></span><br><span class="line">c  <span class="comment">// 'l'</span></span><br><span class="line">d  <span class="comment">// 'l'</span></span><br><span class="line">e  <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>因为字符串还有个 <code>length</code> 属性，所以这个属性也可被解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 <code>undefined</code> 和 <code>null</code> 无法转换成对象，所以对它们进行解构的时候，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: x&#125; = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: y&#125; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot destructure property `prop` of 'undefined' or 'null'.</span></span><br></pre></td></tr></table></figure><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">//[3, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认值的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);     <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);           <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;);               <span class="comment">// [0, 0]</span></span><br><span class="line">move();                 <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>不过，如果用下面的写法，会得到不一样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);     <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);           <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;);               <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move();                 <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面这段代码是为函数 <code>move</code> 的参数指定默认值，而不是为 <code>x</code> 和 <code>y</code> 变量指定默认值，所以会得到不同结果。</p><p><code>undefined</code> 就会触发函数参数的默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [1, 'yes', 3]</span></span><br></pre></td></tr></table></figure><h2 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h2><p>解构的过程中，如果模式中出现了圆括号，可能会引起处理上的歧义。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><h4 id="变量声明语句"><a href="#变量声明语句" class="headerlink" title="变量声明语句"></a>变量声明语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">o</span>: (&#123;<span class="attr">p</span>: p&#125;)&#125; = &#123;<span class="attr">o</span>: &#123;<span class="attr">p</span>: <span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数也属于变量声明，因此不能带有圆括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z, (x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><h4 id="赋值语句的模式"><a href="#赋值语句的模式" class="headerlink" title="赋值语句的模式"></a>赋值语句的模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123;<span class="attr">p</span>: a&#125;) = &#123;<span class="attr">p</span>: <span class="number">42</span>&#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下均正确</span></span><br><span class="line">[(b)] = [<span class="number">3</span>];                <span class="comment">// 模式取的是数组的第一个成员，跟圆括号无关</span></span><br><span class="line">(&#123;<span class="attr">p</span>: (d)&#125; = &#123;&#125;);            <span class="comment">// 模式是 p，不是 d</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>];    <span class="comment">// 跟第一行一样，取的是数组的第一个成员，跟圆括号无关</span></span><br></pre></td></tr></table></figure><p>除了上面注释里写明的原因，上面三行都能正确执行的原因，是<strong>它们都是赋值语句</strong>，而<strong>不是声明语句</strong>。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><p>函数只有一个返回值，如果要返回多个值，只能将它们放在数组或者对象里返回。然后用解构赋值取出它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;foo, bar&#125; = example();</span><br></pre></td></tr></table></figure><h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h3><p>解构赋值可以方便的将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">'OK'</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;id, status, <span class="attr">data</span>: number&#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, 'OK', [867, 5309]</span></span><br></pre></td></tr></table></figure><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在-Vuex-中的应用"><a href="#在-Vuex-中的应用" class="headerlink" title="在 Vuex 中的应用"></a>在 Vuex 中的应用</h2><p>创建带命名空间的辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  mapGetters: postsGetters,</span><br><span class="line">  mapActions: postsActions</span><br><span class="line">&#125; = createNamespacedHelpers(<span class="string">'posts'</span>);</span><br></pre></td></tr></table></figure><p>然后添加组件定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...postsGetters([</span><br><span class="line">      <span class="string">'draft'</span>,</span><br><span class="line">      <span class="string">'currentPost'</span></span><br><span class="line">    ]),</span><br><span class="line">    cssClass() &#123;</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'blog-content'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">'has-content'</span>: <span class="keyword">this</span>.currentPost</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重命名带命名空间的辅助函数是个很好的实践，因为未来可能还会为其他模块添加辅助函数。例如，如果不这么做，可能最后会有两个 <code>mapGetters</code>，而这是不可行的。这里将 <code>mapGetters</code> 重命名为 <code>postsGetters</code>，同时将 <code>mapActions</code> 重命名为 <code>postsActions</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">变量的解构赋值</a></p><p>本文基本是上面链接的笔记和再整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继续第二章，变量的解构赋值。&lt;/p&gt;
&lt;h2 id=&quot;什么是解构赋值&quot;&gt;&lt;a href=&quot;#什么是解构赋值&quot; class=&quot;headerlink&quot; title=&quot;什么是解构赋值&quot;&gt;&lt;/a&gt;什么是解构赋值&lt;/h2&gt;&lt;p&gt;ES6 允许按照一定的&lt;strong&gt;模式&lt;/stron
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://zhcexo.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习Vuex源码前的准备——数组的扩展运算符</title>
    <link href="http://zhcexo.com/2019/03/20/spread-syntax/"/>
    <id>http://zhcexo.com/2019/03/20/spread-syntax/</id>
    <published>2019-03-20T05:55:39.000Z</published>
    <updated>2019-03-20T07:43:47.238Z</updated>
    
    <content type="html"><![CDATA[<p>试了一下 Vue，然后也学习了一下 Vuex，发现 Vuex 的源代码好像不长，就想看看试试。不过由于是用 ES6+ 写的，与传统的写法有点不同，所以如果没有看过 ES6+，那么有必要了解一些必备的知识。</p><h2 id="数组的扩展运算符"><a href="#数组的扩展运算符" class="headerlink" title="数组的扩展运算符"></a>数组的扩展运算符</h2><p>扩展运算符是三个点 <code>...</code>，用于将一个<strong>数组</strong>转为用逗号分隔的<strong>参数序列</strong>，它主要用于<strong>函数调用</strong>。</p><p>要注意上面提到的，是转化为<strong>参数序列</strong>，并不是单单用于数组拆解的，所以如果你打开 DevTools 的 console，在里面输入 <code>...[1, 2, 3]</code>，那么你不会得到 <code>1,2,3</code>，而是会得到一个错误：<code>Uncaught SyntaxError: Unexpected token ...</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br><span class="line"></span><br><span class="line">&#123;...document.querySelectorAll(<span class="string">'div'</span>)&#125;</span><br><span class="line"><span class="comment">// &#123;0: &lt;div&gt;, 1: &lt;div&gt;, 2: &lt;div&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers);    <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>注意上面的例子，把解构出来的值，放到数组 <code>[]</code> 里面，那么得到的是个数组；而如果把解构出来的值，放到对象 <code>{}</code> 里面，那么会得到一个以 <code>index</code> 为 <code>key</code>，元素为 <code>value</code> 的对象，这个对象是没有 <code>length</code> 属性的。</p><p>扩展运算符后面可以放置<strong>表达式</strong>。如果扩展运算符后面是一个空数组，则不产生任何效果。另外，扩展运算符如果放在括号中，JavaScript 引擎会认为这是函数调用，<strong>如果这时不是函数调用，就会报错</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  ...(x &gt; <span class="number">0</span> ? [<span class="string">'a'</span>] : []),</span><br><span class="line">  <span class="string">'b'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">[...[], <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexprected token ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexprected token ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><p>由于扩展运算符可以展开数组，所以不再需要 <code>apply</code> 方法，将数组转为函数的参数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是用扩展运算符取代 <code>apply</code> 方法的一个实际例子，应用 <code>Math.max</code> 方法，简化求出一个数最大元素的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>数组是复合数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。下面的代码中，<code>a2</code> 并不是 <code>a1</code> 的克隆，而是指向同一份数据的另一个指针。修改 <code>a2</code> 会直接导致 <code>a1</code> 的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>在 ES5 中，一般使用变通的方法来复制数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>用扩展运算符来写的话，就会比较简便，两种写法里，<code>a2</code> 都是 <code>a1</code> 的克隆：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h4><p>扩展运算符提供了数组合并的新写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> a3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧的写法</span></span><br><span class="line">a1.concat(a2, a3);</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line">[...a1, ...a2, ...a3]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><p>如果数据里面的元素，是复合的数据类型，无论是 <code>concat</code> 还是用解构运算符，都是<strong>浅复制</strong>，也就是，新数组里面的成员，依然是对原数组成员的引用（指针），如果修改了原数组成员，那么新数组中成员也会变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.concat(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>]     <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>]     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="与解构赋值结合"><a href="#与解构赋值结合" class="headerlink" title="与解构赋值结合"></a>与解构赋值结合</h4><p>扩展运算符可以与解构赋值结合起来，用于生成数组。如果将扩展运算符用于数组赋值，<strong>只能放在参数的最后一位</strong>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">'foo'</span>];</span><br><span class="line">first <span class="comment">// "foo"</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Rest element must be last element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Rest element must be last element</span></span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>扩展运算符可以将字符串转化为真正的数组，<strong>而且能正确识别四个字节的 Unicode 字符</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\uD83D\uDE80'</span>.length   <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// \uD83D\uDE80 是一个四字节的 Unicode 字符，所以 length 应该是 1</span></span><br><span class="line"><span class="comment">// 但是直接用 length 被识别成了 2 个字符</span></span><br><span class="line"></span><br><span class="line">[...<span class="string">'\uD83D\uDE80'</span>].length  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 用扩展运算符就能正确识别</span></span><br></pre></td></tr></table></figure><h2 id="在-Vue-中的应用"><a href="#在-Vue-中的应用" class="headerlink" title="在 Vue 中的应用"></a>在 Vue 中的应用</h2><p>在 Vue 中，主要使用 Vuex 中的 <code>mapGetters</code> 和 <code>mapActions</code> 方法，来简化代码写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    <span class="string">'center'</span>,</span><br><span class="line">    <span class="string">'zoom'</span>,</span><br><span class="line">    <span class="string">'draft'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'setCenter'</span>,</span><br><span class="line">    <span class="string">'setUserPosition'</span>,</span><br><span class="line">    <span class="string">'setZoom'</span>,</span><br><span class="line">    <span class="string">'setDraftLocation'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;试了一下 Vue，然后也学习了一下 Vuex，发现 Vuex 的源代码好像不长，就想看看试试。不过由于是用 ES6+ 写的，与传统的写法有点不同，所以如果没有看过 ES6+，那么有必要了解一些必备的知识。&lt;/p&gt;
&lt;h2 id=&quot;数组的扩展运算符&quot;&gt;&lt;a href=&quot;#数组
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://zhcexo.com/tags/javascript/"/>
    
      <category term="vuex" scheme="http://zhcexo.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>cssnano压缩了CSS动画中keyframes的名字</title>
    <link href="http://zhcexo.com/2019/03/15/cssnano-renames-css-keyframes/"/>
    <id>http://zhcexo.com/2019/03/15/cssnano-renames-css-keyframes/</id>
    <published>2019-03-15T12:04:18.000Z</published>
    <updated>2019-03-15T12:26:10.612Z</updated>
    
    <content type="html"><![CDATA[<p>最近在迁移一些老代码，移动端有一个 loading 动画是用 CSS3 写的，正常得不得了。可是把它集成到 webpack 使用的 scss 里之后，动画效果就丢掉了。找到 scss 转换出来的 css，查找出问题的代码，发现里面的 <code>@keyframes bouncedelay</code> 变成了 <code>@keyframes a</code>，查看了一下 webpack 的配置文件，把问题原因锁定到 cssnano 上。</p><p>首先是找到了 cssnano 的官网，配置项很多，感觉一个个看下来太浪费时间，直接就找问题本身。于是乎在 github 上找到了一个 issue，按别人提供的方法，果然解决了问题。</p><p>修改 webpack 配置，方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改之前</span></span><br><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        plugins: <span class="function">(<span class="params">loader</span>) =&gt;</span> [</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(),</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">                zindex: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改之后</span></span><br><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        plugins: <span class="function">(<span class="params">loader</span>) =&gt;</span> [</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(),</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(&#123;</span><br><span class="line">                zindex: <span class="literal">false</span>,</span><br><span class="line">                reduceIdents: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 webpack 的配置之后再试，打包出来的代码中 bouncedelay 就没有变成 a 了。</p><p>补充说明：</p><ul><li>cssnano 的 <code>reduceIdents</code> 选项，是用于去掉 css 中 “用户自定义字符串标识符” 的 postcss 插件</li><li>由于不同方式处理出不同的 css 样式表，可能会出现在同一个网页中，所以也可能发生 keyframes 这个名相互覆盖的问题，所以建议在使用 cssnano 的时候，始终将这个选项置为 <code>false</code>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/cssnano/cssnano/issues/247" target="_blank" rel="noopener">cssnano renames css keyframes to “a”</a></li><li><a href="https://github.com/ben-eb/postcss-reduce-idents" target="_blank" rel="noopener">postcss-reduce-idents</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/custom-ident" target="_blank" rel="noopener">MDN 上 <custom-ident> 的介绍</custom-ident></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在迁移一些老代码，移动端有一个 loading 动画是用 CSS3 写的，正常得不得了。可是把它集成到 webpack 使用的 scss 里之后，动画效果就丢掉了。找到 scss 转换出来的 css，查找出问题的代码，发现里面的 &lt;code&gt;@keyframes bou
      
    
    </summary>
    
    
      <category term="css" scheme="http://zhcexo.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>最近尝试Vue遇到的坑：安装bcrypt和命令行大小写错误提示</title>
    <link href="http://zhcexo.com/2019/03/08/node-bcrypt-and-vue-casing/"/>
    <id>http://zhcexo.com/2019/03/08/node-bcrypt-and-vue-casing/</id>
    <published>2019-03-08T07:02:32.000Z</published>
    <updated>2019-03-08T07:54:45.280Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山——</p><h3 id="关于-Vue-的"><a href="#关于-Vue-的" class="headerlink" title="关于 Vue 的"></a>关于 Vue 的</h3><h4 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h4><p>我看的教材上，用的 vue-cli，以前的安装方式就是 <code>npm install -g vue-cli</code>，但是新版本变成了 <code>npm install -g @vue/cli</code>。</p><p>其实<a href="https://cli.vuejs.org/guide/" target="_blank" rel="noopener">官方的文档</a>有说，但是我没有注意而已……老版本的 <code>vue-cli</code> 是 v2 版本，新版的 <code>@vue/cli</code> 是 v3 版本。</p><h4 id="npm-run-dev-时遇到的警告提示"><a href="#npm-run-dev-时遇到的警告提示" class="headerlink" title="npm run dev 时遇到的警告提示"></a>npm run dev 时遇到的警告提示</h4><p>另一个问题是，使用 <code>vue init</code> 建立新项目之后，在命令行中运行 <code>npm run dev</code> 居然出了黄色的警告提示：<strong>There are multiple modules with names that only differ in casing.</strong> 比较迷的是，我头一天用的时候，是没有任何提示的，第二天回公司，重新运行，就出一大堆提示了。找了一堆资料，大概有两种原因：</p><blockquote><ul><li>用 <code>import Vue from &#39;Vue&#39;</code> 这样的写法引用了模块，应该改成小写的：<code>import Vue from &#39;vue&#39;</code></li><li>使用了会区分大小写的命令行，例如 git bash 或者 powershell</li></ul></blockquote><p>我自己遇到的问题是第二种，头一天用的 cmd 命令行，第二天用的 powershell，所以就出问题了。有遇到相同问题的朋友，可以找找看，是不是这两个原因。</p><h3 id="关于-node-的"><a href="#关于-node-的" class="headerlink" title="关于 node 的"></a>关于 node 的</h3><h4 id="安装-node-gyp"><a href="#安装-node-gyp" class="headerlink" title="安装 node-gyp"></a>安装 node-gyp</h4><p>下载了网上的一个测试 node 服务器，用里面的 <code>package.json</code> 文件，用 <code>npm install</code> 安装之后，不停报错。分析命令行提示，缺少 <code>node-gyp</code>。继续在网上找资料，<code>node-gyp</code> 是没有整合到 <code>nodejs</code> 的安装包里，需要自己编译安装。而要在 windows 平台上编译安装，又需要安装 <a href="https://github.com/felixrieseberg/windows-build-tools" target="_blank" rel="noopener"><code>windows-build-tools</code></a>。</p><p>按项目说明来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g --production windows-build-tools</span><br></pre></td></tr></table></figure><p>然后，然后就特么一直卡在那里不动了……</p><p>又找了一堆资料，好像是最新版本的这个工具有问题，安装 <code>4.0.0</code> 的就不会出错，那么再来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g --production windows-build-tools@4.0.0</span><br></pre></td></tr></table></figure><p>等待命令行窗口里面该搞的搞完了，就可以继续输入命令安装 <code>node-gyp</code> 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g node-gyp</span><br></pre></td></tr></table></figure><h4 id="安装-bcrypt"><a href="#安装-bcrypt" class="headerlink" title="安装 bcrypt"></a>安装 bcrypt</h4><p><code>bcrypt</code> 的安装需要依赖 <code>node-gyp</code>，所以上面才折腾半天的。但问题是，如果直接按下载的 <code>package.json</code> 提供的版本安装 <code>1.x.x</code> 版本时，会提示 github 上找不到……</p><p>OK，还是安最新的吧。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bcrypt</span><br></pre></td></tr></table></figure><h4 id="不要忽略-package-lock-json-文件的影响"><a href="#不要忽略-package-lock-json-文件的影响" class="headerlink" title="不要忽略 package-lock.json 文件的影响"></a>不要忽略 package-lock.json 文件的影响</h4><p>前不久重装了一下系统，然后安装了一下需要用的工具。在我的工具文件夹里，使用 <code>npm install</code> 的时候，总是提示 <code>base64-url 安装错误，/path/to/base64-url.tar.gz 文件不存在</code>，而且这个 <code>path</code> 是一个本地路径，也是一个无法在 windows 系统里存在的路径。</p><p>折腾半天无果，发现是被同目录下的 <code>package-lock.json</code> 影响了。因为之前从 <code>cnpm</code> 切换到 <code>npm</code> 时，生成的 <code>package-lock.json</code> 基于了当时安装好的 node 模块，所以路径指向了本地。</p><p>我删掉 <code>package-lock.json</code> 之后再装新版本，就没这些问题了。当然，有些版本变化较大的工具，还是要卸载后安装对应的旧版，也挺糟心的。</p><h4 id="一个好用的工具-nrm"><a href="#一个好用的工具-nrm" class="headerlink" title="一个好用的工具 nrm"></a>一个好用的工具 nrm</h4><p>什么是 nrm？</p><blockquote><p>nrm can help you easy and fast switch between different npm registries, now include: npm, cnpm, taobao, nj(nodejitsu).</p></blockquote><p>就是用来快速切换 npm 源的一个管理工具，里有 npm 原始源地址，也有淘宝和其他的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><p>安装之后，直接在命令行里用 <code>nrm ls</code> 就可以显示已经有的源，和正在使用的源；用 <code>nrm use [name]</code> 就能切换到指定源了，例如 <code>nrm use taobao</code>。用 <code>nrm</code> 来完成这些小动作真的会省心不少，推荐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开门见山——&lt;/p&gt;
&lt;h3 id=&quot;关于-Vue-的&quot;&gt;&lt;a href=&quot;#关于-Vue-的&quot; class=&quot;headerlink&quot; title=&quot;关于 Vue 的&quot;&gt;&lt;/a&gt;关于 Vue 的&lt;/h3&gt;&lt;h4 id=&quot;vue-cli&quot;&gt;&lt;a href=&quot;#vue-cli&quot;
      
    
    </summary>
    
    
      <category term="node" scheme="http://zhcexo.com/tags/node/"/>
    
      <category term="vue" scheme="http://zhcexo.com/tags/vue/"/>
    
      <category term="powershell" scheme="http://zhcexo.com/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>为nginx配置vhosts（Windows开发环境）</title>
    <link href="http://zhcexo.com/2018/10/29/add-nginx-vhosts/"/>
    <id>http://zhcexo.com/2018/10/29/add-nginx-vhosts/</id>
    <published>2018-10-29T08:57:36.000Z</published>
    <updated>2018-10-29T09:23:44.911Z</updated>
    
    <content type="html"><![CDATA[<p>公司开发了自己的页面渲染系统，而且涉及需要迁移的站点非常多，所以需要在开发中配置一些虚拟主机。以前玩的都是 Apache，但是后端推荐使用比较轻量的 nginx，所以扒了一下 nginx 的 vhosts 的配置方法。</p><p><strong>首先</strong>，下载 nginx 的可执行文件，是个压缩文件，解压之后，放到一个容易访问的目录，以下用 <code>nginx_dir</code> 代替。ngnix 的默认配置文件是 <code>nginx_dir/conf/nginx.conf</code>。</p><p><strong>其次</strong>，在 <code>nginx_dir/conf/</code> 下新建一个目录，叫 <code>vhosts</code>，并且在 <code>nginx_dir/conf/vhosts/</code> 下新建一个文件，名为 <code>vhosts.conf</code>。</p><p><strong>第三</strong>，在 <code>nginx_dir/conf/nginx.conf</code> 的配置里，位于 <code>http {...}</code> 的最后面，于 <code>}</code> 之前，添加 <code>include vhosts/*.conf;</code>。添加的代码意义为：在 <code>nginx.conf</code> 中引入 <code>vhosts</code> 下所有的 <code>.conf</code> 文件。</p><p>以下即是 <code>vhosts.conf</code> 里面的配置，因为开发中主要用到反向代理，其他的按文档按需添加就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> example 代理相关配置</span><br><span class="line">server &#123;</span><br><span class="line">    # 监听端口号</span><br><span class="line">    listen 7777;</span><br><span class="line">    </span><br><span class="line">    # 反向代理的域名</span><br><span class="line">    server_name example.localhost;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        #本地模拟服务器地址及端口</span><br><span class="line">        charset utf-8;</span><br><span class="line">        proxy_pass http://127.0.0.1:1987;</span><br><span class="line">        proxy_set_header    Custom-Header 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四</strong>，统统设置完之后，打开命令行，定位到 <code>nginx_dir</code>，使用如下命令检查配置是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx.exe -t</span><br></pre></td></tr></table></figure><p>如果出现以下提示，表明配置没问题，出现其他提示自行排查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration file nginx_dir/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file nginx_dir/conf/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，因为是在 windows 环境下，所以启动 nginx 使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ start nginx.exe</span><br></pre></td></tr></table></figure><p>使用 <code>start</code> 运行而不是直接运行，是让命令行的窗口可以进行别的操作，而不是一直僵在前台。</p><p><strong>补充</strong>：</p><ul><li>使用 <code>nginx -s quit</code> 命令来关闭运行中的 nginx 进程</li><li>使用 <code>nginx -s reload</code> 命令来重启运行中的 nginx，一般用于修改配置文件之后操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司开发了自己的页面渲染系统，而且涉及需要迁移的站点非常多，所以需要在开发中配置一些虚拟主机。以前玩的都是 Apache，但是后端推荐使用比较轻量的 nginx，所以扒了一下 nginx 的 vhosts 的配置方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>一些数组方法的备忘</title>
    <link href="http://zhcexo.com/2018/08/27/array-memo/"/>
    <id>http://zhcexo.com/2018/08/27/array-memo/</id>
    <published>2018-08-27T07:09:38.000Z</published>
    <updated>2018-08-27T09:40:38.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach()</code> 方法对数据的每一个元素执行一次提供的函数</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(callback (currentValue, index, array) &#123;&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 为数组中每个元素执行的函数，接收三个参数</li><li><strong>currentVale</strong> - <code>callback</code> 的第一个参数，当前正处理的元素</li><li><strong>index</strong> - 可选参数，<code>callback</code> 的第二个参数，当前正处理的元素的索引</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第三个参数，是正在处理的数组</li><li><strong>thisArg</strong> - 可选参数，当执行回调函数时用作 this 的值（参考对象）</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>undefined</code></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>没有办法中止或者跳出 forEach 循环，除非抛出一个错误。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code> 方法<strong>创建一个新数组</strong>，包含通过所提供的函数实现的测试的所有元素。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = array.filter(callback (currentValue[, index[, array]]) &#123;&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 用来测试数组每个元素的函数，调用时使用参数 <code>(currentValue, index, array)</code>，返回 <code>true</code> 表示保留该元素（通过了测试），<code>false</code> 则不保留</li><li><strong>currentValue</strong> - <code>callback</code> 的第一个参数，当前正在处理的元素</li><li><strong>index</strong> - 可选参数，<code>callback</code> 的第二个参数，当前正在处理的元素的索引值</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第三个参数，调用 <code>filter</code> 的数组</li><li><strong>thisArg</strong> - 可选参数，当执行回调函数时用作 this 的值（参考对象）</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>一个<strong>新的</strong>通过测试的元素集合的<strong>数组</strong>，如果没有元素通过测试，就返回<strong>空数组</strong>。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map()</code> <strong>创建一个新数组</strong>，新数组中的每个元素，是原数组里每个元素，调用所提供的函数后返回的结果。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = array.map(callback (currentValue[, index[, array]]) &#123;&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 生成新数组元素的函数</li><li><strong>currentVale</strong> - <code>callback</code> 的第一个参数，数组中当前正在处理的元素</li><li><strong>index</strong> - 可选参数，<code>callback</code> 的第二个参数，数组中当前正在处理的元素的索引值</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第三个参数，调用 <code>map</code> 的数组</li><li><strong>thisArg</strong> - 可选参数，执行回调函数时用作 this 的值（参考对象）</li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>一个<strong>新数组</strong>，每个元素都是回调函数的结果。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce()</code> 对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(callback (accumulator, currentValue[, currentIndex[, array]]) &#123;&#125;[, initialValue]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 执行数组中每个值的函数</li><li><strong>accumulator</strong> - <code>callback</code> 的第一个参数，累加器累加回调的返回值，它是上一次调用回调时返回的累积值，或 <code>initialValue</code> </li><li><strong>currentValue</strong> - <code>callback</code> 的第二个参数，数组中当前正在处理的元素</li><li><strong>currentIndex</strong> - 可选参数，<code>callback</code> 的第三个参数，数组中当前正在处理的元素的索引。如果提供了 <code>initialValue</code>，则索引号为 0，否则索引为 1</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第四个参数，调用 <code>reduce</code> 的数组</li><li><strong>initialValue</strong> - 可选参数，用作第一个调用 <code>callback</code> 的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。在没有初始值的空数上调用 <code>reduce</code> 会报错</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>函数累计处理的结果</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果没有提供 <code>initialValue</code>，<code>reduce</code> 会从索引 1 的地方开始执行 callback 方法，跳过第一个索引。如果提供 <code>initialValue</code>，从索引 0 开始。</p><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p><code>reduceRight</code> 总体上与 <code>reduce</code> 相同，区别在于，使用数组中的值，从右向左传给 <code>callback</code></p><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><code>every()</code> 测试数组中所有元素是否都通过了指定函数的测试。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.every(callback (currentValue[, index[, array]]) &#123;&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 用来测试每个元素的函数</li><li><strong>currentValue</strong> - <code>callback</code> 的第一个参数，当前处理的元素</li><li><strong>index</strong> - 可选参数，<code>callback</code> 的第二个参数，当前处理的元素的索引值</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第三个参数，调用 <code>every</code> 的数组</li><li><strong>thisArg</strong> - 可选参数，执行 <code>callback</code> 时使用的 this 值</li></ul><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>如果每个元素都通过了测试函数，则返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><p>在空数组上调用 <code>every</code> 方法，无论测试函数是什么，都会返回 <code>true</code>。</p><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><code>some()</code> 测试数组中某些元素是否通过指定函数的测试。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.some(callback (currentValue[, index[, array]]) &#123;&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><ul><li><strong>callback</strong> - 测试函数</li><li><strong>currentValue</strong> - <code>callback</code> 的第一个参数，当前正在处理的元素</li><li><strong>index</strong> - 可选参数，<code>callback</code> 的第二个参数，当前正在处理的元素的索引值</li><li><strong>array</strong> - 可选参数，<code>callback</code> 的第三个参数，调用 <code>some</code> 的数组</li><li><strong>thisArg</strong> - 可选参数，执行 <code>callback</code> 时使用的 this 值</li></ul><h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>如果任意一个元素通过了测试函数，就返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>在空数组上调用 <code>some</code> 方法，无论测试函数是什么，都会返回 <code>false</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;forEach&quot;&gt;&lt;a href=&quot;#forEach&quot; class=&quot;headerlink&quot; title=&quot;forEach&quot;&gt;&lt;/a&gt;forEach&lt;/h2&gt;&lt;p&gt;&lt;code&gt;forEach()&lt;/code&gt; 方法对数据的每一个元素执行一次提供的函数&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://zhcexo.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>安装Simple Obfs</title>
    <link href="http://zhcexo.com/2018/08/16/how-to-install-simple-obfs/"/>
    <id>http://zhcexo.com/2018/08/16/how-to-install-simple-obfs/</id>
    <published>2018-08-16T05:34:45.000Z</published>
    <updated>2018-08-16T06:03:36.597Z</updated>
    
    <content type="html"><![CDATA[<p>非常不爽，不知道最近 WALL 是做了什么升级，我的 55 挂了，使用 chacha20-ietf-poly1305 都不行，之前还用着挺好的。无奈只好又寻方法，找到了 Simple Obfs。</p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p><strong>以下命令均在 root 权限下执行，所以无 sudo</strong></p><p>废话不多说，先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/shadowsocks/simple-obfs.git</span><br><span class="line"><span class="built_in">cd</span> simple-obfs</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>使用 Simple Obfs 有两种方式，一种是作为 55 的插件，另一种是独立模式，我怕麻烦，所以使用作为 55 插件的方法。以前用的是 Python 版的 55，不支持外挂插件的样子，所以换成 55-libev。安装之：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install shadowsocks-libev</span><br></pre></td></tr></table></figure><p>如果安装成功了，在命令行下输入 <code>ss-server</code> 会出现相应提示的，这一步不详说。（要注意的是，Python 版的命令是 <code>ssserver</code>，55-libev 的命令是 <code>ss-server</code>，有一横杠的区别）</p><p>接下来修改 55 的配置文件，在配置文件里，添加两行参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugin"</span>: <span class="string">"obfs-server"</span>,</span><br><span class="line"><span class="string">"plugin_opts"</span>: <span class="string">"obfs=http"</span></span><br></pre></td></tr></table></figure><p>万事具备，使用如下命令启动 55：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-server -c config.json</span><br></pre></td></tr></table></figure><p>如果输出没有报错，就表明启动正常，接下来按 <code>Ctrl+C</code> 结束掉。为啥？当然是重新开始后台启动啊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ss-server -c config.json &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>注释：</p><ul><li><code>/dev/null</code> 代表空设备文件</li><li><code>&gt;</code> 表示重定向到哪里，例如： <code>echo &quot;123&quot; &gt; /home/123.txt</code></li><li><code>2</code> 表示 stderr 标准错误</li><li><code>&amp;</code> 表示等同于的意思，表示 2 的输出重定向等同于 1</li><li><code>1</code> 表示 stdout 标准输出，系统默认是 1，所以 <code>&gt; /dev/null</code> 等同于 <code>1 &gt; /dev/null</code></li><li><code>&gt; /dev/null</code> 表示标准输出重定向到空设备文件，也就是不输出任何信息到终端</li><li><code>2&gt;&amp;1</code> 接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件</li><li><code>结尾处的 &amp;</code> 将命令同时放入后台运行</li></ul><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>下载 obfs-local，<strong>然后把压缩包里面的两个文件，解压到 55 相同的目录里面</strong>。接着打开 55 的服务器配置界面，把 <strong>插件程序</strong> 和 <strong>插件选项</strong> 两个空位置，填写如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插件程序：obfs-local</span><br><span class="line">插件选项：obfs=http;obfs-host=www.bing.com</span><br></pre></td></tr></table></figure><p>到此为止，全部完成，终于又能用 Google 了~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://teddysun.com/511.html" target="_blank" rel="noopener">如何安装和配置simple-obfs服务端</a></li><li><a href="https://blog.csdn.net/wwzuizz/article/details/78194159" target="_blank" rel="noopener">55-libev</a></li><li><a href="https://roxhaiy.wordpress.com/2014/07/29/%E5%9C%A8linux%E9%85%8D%E7%BD%AEshadowsocks-libev%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%BF%9B%E8%A1%8C%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" target="_blank" rel="noopener">配置55-libev服务器端进行KX上网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非常不爽，不知道最近 WALL 是做了什么升级，我的 55 挂了，使用 chacha20-ietf-poly1305 都不行，之前还用着挺好的。无奈只好又寻方法，找到了 Simple Obfs。&lt;/p&gt;
&lt;h2 id=&quot;服务端配置&quot;&gt;&lt;a href=&quot;#服务端配置&quot; cla
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Grid 布局完全指南</title>
    <link href="http://zhcexo.com/2018/08/15/a-complete-guide-to-grid/"/>
    <id>http://zhcexo.com/2018/08/15/a-complete-guide-to-grid/</id>
    <published>2018-08-15T06:11:59.000Z</published>
    <updated>2018-08-15T06:32:38.460Z</updated>
    
    <content type="html"><![CDATA[<p>Grid 布局是 CSS 中最强大的布局方式。它是一个二维系统，也就是说，它能同时处理行和列，而不像 <code>flexbox</code> 这样是一个一维系统。使用 Grid 布局方式可以同时将 CSS 规则作用于父元素（成为 Grid Container）和子元素（成为 Grid Items）。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CSS Grid Layout（又叫做 Grid），是一个二维的、基于网格的布局系统，目标是完全改变我们基于网格设计的用户界面。CSS 已经常用于 web 页面的布局，但并不是总做得非常好。开始，我们使用表格 tables 布局，然后使用浮动 floats，定位 position 和 inline-block，但说到底，这些方法都算作 hacks，漏掉了一些重要的功能性（比如垂直剧中）。Flexbox 可以解决问题，但是它是为简单的一维布局而设计的，并不是为复杂的二维布局而设计（Flexobox 和 Grid 事实上可以同时工作）。Grid 是最开始为解决布局问题而创造出来的 CSS 模块。</p><p>写这篇指南出于两个基本原因：一是 Rachel Andrew 写佳作 <a href="http://abookapart.com/products/get-ready-for-css-grid-layout" target="_blank" rel="noopener">Get Ready for CSS Grid Layout</a>，它是一本清楚而透彻介绍 Grid 的书，也是本文的基础所在，我高度建议大家买来读一下。另一个原因是 Chris Coyier 的 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a>，它是我定位 flexbox 问题的随手工具书，它同时也帮助了一大批的人，你在 Google “flexbox” 的时候，它也出现在明显位置。你可以注意到他和我文章的很多相似之处，因为有最好的，为啥不借用？</p><p>我写这个指南主要目的是介绍 Grid 的概念，因为它已经出现在了最新版的规范里。所以我也不会涵盖到已过时的 IE 浏览器，并且当规范成熟时，尽量更新这份指南。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>要开始使用 Grid，首先要定义一个容器元素，使用 <code>display: grid</code>，然后设置列和行的尺寸，使用 <code>grid-template-column</code> 和 <code>grid-template-rows</code>，接着用 <code>grid-column</code> 和 <code>grid-row</code> 安置它的子元素。与 flexbox 类似，代码出现的顺序与 grid items 的排列没有关系。CSS 代码层面可以用任何顺序来写，而且使用媒体查询可以很容易地把 grid 重排。想象一下把整个页面都布局好，然后用几行 CSS 代码将它完全重排以适应不同的屏幕宽度。Grid 是迄今介绍过的最强大的 CSS 模块。</p><h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2><p>深入 Grid 概念之前有些重要术语需要知道。因为这里包含的规则概念上相似，所以如果不先记住 Grid 规范中定义的术语，很容易在使用的时候相互混淆。不过不用担心，因为术语没有很多。</p><h3 id="Grid-Container"><a href="#Grid-Container" class="headerlink" title="Grid Container"></a>Grid Container</h3><p>使用了 <code>display: grid</code> 的元素即为 Grid Container。它是所有 grid items 的直接父元素。在下面这个例子中，<code>container</code> 就是 grid container。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Grid-Item"><a href="#Grid-Item" class="headerlink" title="Grid Item"></a>Grid Item</h3><p>Grid Container 元素的直接子元素。下面的例子中，<code>item</code> 元素就是 grid items，但是 <code>sub-item</code> 元素不是。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sub-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Grid-Line"><a href="#Grid-Line" class="headerlink" title="Grid Line"></a>Grid Line</h3><p>这些分割线组成了 grid 的结构。它们可以是垂直的（column grid lines）或者水平的（row grid lines），或者位于 row 或 column 的两侧。图示的黄线就是一个 column grid line。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-line.png" alt="grid line"></p><h3 id="Grid-Track"><a href="#Grid-Track" class="headerlink" title="Grid Track"></a>Grid Track</h3><p>位于两条 grid line 之间的空间。可以想像成 grid 里的列或者行。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-track.png" alt="grid track"></p><h3 id="Grid-Cell"><a href="#Grid-Cell" class="headerlink" title="Grid Cell"></a>Grid Cell</h3><p>位于两相邻行和两相邻列的 grid lines 之间的空间。它是 grid 布局里面的“单元”。图示中是行的 grid lines 1 和 2，以及列的 grid lines 2 和 3 之间的 grid cell。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-cell.png" alt="grid cell"></p><h3 id="Grid-Area"><a href="#Grid-Area" class="headerlink" title="Grid Area"></a>Grid Area</h3><p>被四条 grid lines 包围的总体空间就是 Grid Area。一个 grid area 可以由任意个数的 grid cells 组成。图示中是 1 和 3 行 grid lines 以及 1 和 3 列 grid lines 包围而成的 grid area。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-area.png" alt="grid area"></p><h2 id="Grid-属性表"><a href="#Grid-属性表" class="headerlink" title="Grid 属性表"></a>Grid 属性表</h2><h3 id="用于-Grid-Container-的属性（即父元素的属性）"><a href="#用于-Grid-Container-的属性（即父元素的属性）" class="headerlink" title="用于 Grid Container 的属性（即父元素的属性）"></a>用于 Grid Container 的属性（即父元素的属性）</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>把元素定义为 grid container 从而为它的内容形成一个新的 grid formatting context。</p><h5 id="值："><a href="#值：" class="headerlink" title="值："></a>值：</h5><ul><li><strong>grid</strong> - 产生一个块级的 grid</li><li><strong>inline-grid</strong> - 产生一个内联级的 grid</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: The ability to pass grid parameters down through nested elements (aka subgrids) has been moved to <a href="https://www.w3.org/TR/css-grid-2/#subgrids" target="_blank" rel="noopener">level 2 of the CSS Grid specification</a>. Here’s <a href="https://css-tricks.com/grid-level-2-and-subgrid/" target="_blank" rel="noopener">a quick explanation</a>.</p><h4 id="grid-template-columns-和-grid-template-rows"><a href="#grid-template-columns-和-grid-template-rows" class="headerlink" title="grid-template-columns 和 grid-template-rows"></a>grid-template-columns 和 grid-template-rows</h4><p>定义列和行，使用空格将这些属性值连起来。这些值包含了 track size，它们之间的空间代表的是 grid line。</p><h5 id="值：-1"><a href="#值：-1" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;track-size></strong> - 可以取长度、百分比、grid 中空白空间的一部分（使用 <code>fr</code> 单元）</li><li><strong>&lt;line-name></strong> - 可以取任意名字</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt;...;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><p>当在 track 的值上留空时，grid lines 会自己分配正值或负值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">25%</span> <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2018/04/grid-numbers.png" alt="grid-template"></p><p>也可以为这些 lines 指一个固定的名字，注意一下 line 名的括号语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: [first] <span class="number">40px</span> [line2] <span class="number">50px</span> [line3] auto [col4-start] <span class="number">50px</span> [five] <span class="number">40px</span> [end];</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end] <span class="number">100px</span> [third-line] auto [last-line];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-names.png" alt="line-name"></p><p>要注意的是，一条 line 可以拥有不止一个名字。例如，第二条 line 拥有两个名字：row1-end 和 row2-start：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end row2-start] <span class="number">25%</span> [row2-end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义的时候有重复部分，那么可以直接使用 <code>repeat()</code> 记号进行组织：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 20px [col-start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个 lines 使用相同的名字，它们会参照 line name 和计数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: col-start <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fr</code> 单元允许你使用 gird container 中的空白空间去设置 track 的尺寸。例如，下面的代码会将每个 item 的宽度设置为 grid container 宽的 1/3。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空白空间是去除固定 item 之后的值来计算的。下面的例子表示，用于 <code>fr</code> 来表示的空白空间，不包括这 50px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h4><p>先用 <code>grid-area</code> 属性来定义 grid areas 的名字，之后参照这些名字来定义 grid template。Repeating the name of a grid area causes the content to span those cells. 一个点号 <code>.</code> 表示一个空的 cell。语法的本身就提供了 gird 视觉化的结构。</p><h5 id="值：-2"><a href="#值：-2" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;grid-area-name></strong> - 使用 <code>grid-area</code> 指定的 grid area 的名字</li><li><strong>.</strong> - 空 grid cell</li><li><strong>none</strong> - 没有 grid areas 被定义</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>:</span><br><span class="line">        <span class="string">"&lt;grid-area-name&gt; | . | none | ... "</span></span><br><span class="line">        <span class="string">"..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: auto;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: </span><br><span class="line">        <span class="string">"header header header header"</span></span><br><span class="line">        <span class="string">"main main . sidebar"</span></span><br><span class="line">        <span class="string">"footer footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码产生了一个四列宽度三行高的 grid 。整个的顶部行都会组成 <strong>header</strong> 区。中间的行会组成 <strong>main</strong> 区，一个空白 cell，一个 <strong>sidebar</strong> 区。最后一行全部组成 <strong>footer</strong>。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-template-areas.png" alt="grid-template-area"></p><p>声明中的每一行，必须有相同的 cell 数目。</p><p>可以使用任意数量的点号来指定单个空白的 cell。只要点号之间没有其他的空白，那么它们就会组成一个空白 cell。</p><p>要注意不能使用这个语法来命名 lines，只能用它来命名 areas。当使用它来命名 areas 的时候，area 两边的 lines 会被自动命名的。如果你的 grid area 的名字是 <strong>foo</strong>，那么这个 area 的起始 row line 和起始 column line 就会被命名为 <strong>foo-start</strong>，并且最后一个 row line 和最后一个 column line 会被命名为 <strong>foo-end</strong>。这就意味着，一些 lines 会有多个命名，比如上个例子中最左边的 line，它就拥有三个名字：header-start，main-start 和 footer-start。</p><h4 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h4><p>这个属性就是 <code>grid-template-rows</code>，<code>grid-template-columns</code>，<code>grid-template-areas</code> 三个属性的缩写。</p><h5 id="值：-3"><a href="#值：-3" class="headerlink" title="值："></a>值：</h5><ul><li><strong>none</strong> - 表示设置为三个属性的初始值</li><li><strong>&lt;grid-template-rows> / &lt;grid-template-columns></strong> - 将 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 分别设置为指定的值，而将 <code>grid-template-area</code> 设置为 <code>none</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template</span>: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它同时也接受，看起来复杂，但是用起来很方便的语法同时指定三个属性，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template</span>: </span><br><span class="line">        [row1-start] <span class="string">"header header header"</span> <span class="number">25px</span> [row1-end]</span><br><span class="line">        [row2-start] <span class="string">"footer footer footer"</span> <span class="number">25px</span> [row2-end]</span><br><span class="line">        / auto <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25px</span> [row1-end row2-start] <span class="number">25px</span> [row2-end];</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: </span><br><span class="line">        <span class="string">"header header header"</span></span><br><span class="line">        <span class="string">"footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-template</code> 并不会重设一些暗藏的属性（比如 <code>grid-auto-columns</code>，<code>grid-auto-rows</code> 和 <code>grid-auto-flow</code>），但往往在很多情况下这是想要进行的设置，所以建议使用 <code>grid</code> 属性来代替 <code>grid-template</code>。</p><h4 id="grid-column-gap-和-grid-row-gap"><a href="#grid-column-gap-和-grid-row-gap" class="headerlink" title="grid-column-gap 和 grid-row-gap"></a>grid-column-gap 和 grid-row-gap</h4><p>用来指定 grid lines 的尺寸。可以想象成设置 column / rows 之间的沟槽的宽度。</p><h5 id="值：-4"><a href="#值：-4" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;line-size></strong> - 长度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-gap</span>: &lt;line-size&gt;;</span><br><span class="line">    <span class="attribute">grid-row-gap</span>: &lt;line-size&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">grid-column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">grid-row-gap</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-column-row-gap.png" alt="gap"></p><p>沟槽仅会在 columns / rows 之间产生，不会在外边界产生。</p><p>注意：<code>grid-</code> 这个前缀将会被移除，到时 <code>grid-column-gap</code> 和 <code>grid-row-gap</code> 会被重命名为 <code>column-gap</code> 和 <code>row-gap</code>。无前缀属性现已经被 Chrome 68+，Safari 11.2 Release 50+ 和 Opera 54+ 所支持。</p><h4 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h4><p><code>grid-row-gap</code> 和 <code>grid-column-gap</code> 的缩写形式</p><h5 id="值：-5"><a href="#值：-5" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;grid-row-gap> &lt;grid-column-gap></strong> - 长度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-gap</span>: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">15px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有设置 <code>grid-row-gap</code>，那么它会被设置为与 <code>grid-column-gap</code> 相同的值。</p><p>注意：<code>grid-</code> 这个前缀将会被移除，到时 <code>grid-gap</code> 会被重命名为 <code>gap</code>。无前缀版属性现已经被 Chrome 68+，Safari 11.2 Release 50+ 和 Opera 54+ 所支持。</p><h4 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h4><p>让 grid items 沿着内联轴（row）对齐（与 <code>align-items</code> 沿着块级轴（column） 相反）。这个属性会对 container 里所有的 grid items 都生效。</p><h5 id="值：-6"><a href="#值：-6" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 items 与 cell 的起始边缘对齐</li><li><strong>end</strong> - 将 items 与 cell 的结束边缘对齐</li><li><strong>center</strong> - 所有 items 在它们的 cell 里水平居中</li><li><strong>stretch</strong> - 填满整个 cell 的宽度（默认值）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-items-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-items-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-items-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-items</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-items-stretch.png" alt="stretch"></p><p>这些表现，也要以在单独的 grid items 上通过 <code>justify-self</code> 属性各自设置。</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>将 grid items 沿着块级轴（column）对齐（与 <code>justify-items</code> 沿着内联轴（row） 相反）。这个属性同样会对 container 里所有的 grid items 都生效。</p><h5 id="值：-7"><a href="#值：-7" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 items 与 cell 的起始边缘对齐</li><li><strong>end</strong> - 将 items 与 cell 的结束边缘对齐</li><li><strong>center</strong> - 所有 items 在它们的 cell 里垂直居中</li><li><strong>stretch</strong> - 填满整个 cell 的高度（默认值）</li></ul><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-items-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-items-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-items-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-items-stretch.png" alt="stretch"></p><p>这些表现，也要以在单独的 grid items 上通过 <code>align-self</code> 属性各自设置。</p><h4 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h4><p><code>place-items</code> 是 <code>align-items</code> 和 <code>justify-items</code> 和缩写方式。</p><h4 id="值：-8"><a href="#值：-8" class="headerlink" title="值："></a>值：</h4><ul><li><strong>&lt;align-items> / &lt;justify-items></strong> - 第一个值设置 <code>align-items</code>，第二个值设置 <code>justify-items</code>。如果第二个值被省略，那么第一个值则同时用于两个属性。</li></ul><p>除了 Edge 之外的所有主流浏览器都支持 <code>place-items</code> 的简写方式。</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>有时所有的 grid 的尺寸之后可能还是小于 grid container，这常发生在指定 grid items 的尺寸的时候，用的是 px 这样的固定单位。在这种情况下，可以设置 grid 在 grid container 里面的对齐方式。这个属性将 grid items 沿着内联轴（row）进行对齐（与 <code>align-content</code> 相反，<code>align-content</code> 是沿着块级轴（column）对齐）。</p><h5 id="值：-9"><a href="#值：-9" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 grid 沿着 grid container 的起始边缘对齐</li><li><strong>end</strong> - 将 grid 沿着 grid container 的结束边缘对齐</li><li><strong>center</strong> - 将 grid 在 grid container 水平居中</li><li><strong>stretch</strong> - 调整 grid items 的大小让 grid 去填满 grid container 的宽度</li><li><strong>space-around</strong> - 在每个 grid item 旁设置偶数个空间，起始端和尾端的空间宽度为其他的半数</li><li><strong>space-between</strong> - 在每个 grid item 旁设置偶数个空间，起始端和尾端不留空间</li><li><strong>space-evenly</strong> - 在每个 grid item 旁设置偶数个空间，包括起始端和尾端</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-stretch.png" alt="stretch"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-space-around.png" alt="around"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-space-between.png" alt="between"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-content-space-evenly.png" alt="evenly"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>有时所有的 grid 的尺寸之后可能还是小于 grid container，这常发生在指定 grid items 的尺寸的时候，用的是 px 这样的固定单位。在这种情况下，可以设置 grid 在 grid container 里面的对齐方式。这个属性将 grid items 沿着块级轴（column）进行对齐（与 <code>justify-content</code> 相反，<code>justify-content</code> 是沿着内联轴（row）对齐）。</p><h5 id="值：-10"><a href="#值：-10" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 grid 沿着 grid container 的起始边缘对齐</li><li><strong>end</strong> - 将 grid 沿着 grid container 的结束边缘对齐</li><li><strong>center</strong> - 将 grid 在 grid container 水平居中</li><li><strong>stretch</strong> - 调整 grid items 的大小让 grid 去填满 grid container 的宽度</li><li><strong>space-around</strong> - 在每个 grid item 旁设置偶数个空间，起始端和尾端的空间宽度为其他的半数</li><li><strong>space-between</strong> - 在每个 grid item 旁设置偶数个空间，起始端和尾端不留空间</li><li><strong>space-evenly</strong> - 在每个 grid item 旁设置偶数个空间，包括起始端和尾端</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-stretch.png" alt="stretch"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-space-around.png" alt="around"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-space-between.png" alt="between"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-content-space-evenly.png" alt="evenly"></p><h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><p><code>place-content</code> 是同时设置 <code>align-content</code> 和 <code>justify-content</code> 属性的简写。</p><h5 id="值：-11"><a href="#值：-11" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;align-content> / &lt;justify-content></strong> - 第一个值设置 <code>align-content</code>，第二个值设置 <code>justify-content</code>，如果第二个值被省略，那么第一个值则同时作用于两个属性设置。</li></ul><p>除了 Edge 之外的所有主流浏览器都支持 <code>place-content</code> 属性。</p><h4 id="grid-auto-columns-和-grid-auto-rows"><a href="#grid-auto-columns-和-grid-auto-rows" class="headerlink" title="grid-auto-columns 和 grid-auto-rows"></a>grid-auto-columns 和 grid-auto-rows</h4><p>指定自动生成的 grid tracks 的尺寸（也就是稳式的 grid tracks）。当 grid items 比 cell 的数量多，或者一个 grid item 被放在了显式的 grid 外面，隐式的 tracks 就会产生。（参见<a href="https://css-tricks.com/difference-explicit-implicit-grids/" target="_blank" rel="noopener">The Difference Between Explicit and Implicit Grids</a>）</p><h5 id="值：-12"><a href="#值：-12" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;track-size></strong> - 可以是长度，百分比或者 <code>fr</code> 单元</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: &lt;track-size&gt; ...;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: &lt;track-size&gt; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下隐式的 grid track 的产生：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">90px</span> <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-auto.png" alt="grid-auto"></p><p>代码创建了一个 2x2 的 grid。</p><p>但是想象一下使用 <code>grid-column</code> 和 <code>grid-row</code> 来放置 grid items：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">5</span> / <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/implicit-tracks.png" alt="grid-auto"></p><p>我们已经指定了 .item-b 从 line 5 开始，并且于 line 6 处结束，<strong>但是我们从来没有定义过 line 5 和 line 6</strong>。因为我们的参考线是不存在的，隐式的宽度为 0 的 tracks 就被创造出来去填充 gaps。我们可以用 <code>grid-auto-columns</code> 和 <code>grid-auto-rows</code> 去指定这些隐式 tracks 的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/implicit-tracks-with-widths.png" alt="grid-auto"></p><h4 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h4><p>如果并没有明确声明 grid 中的 grid items 的位置，那么<strong>自动安放算法</strong>就会生效从而自动排列 items。这个属性控制自动算法如何来生效。</p><h5 id="值：-13"><a href="#值：-13" class="headerlink" title="值："></a>值：</h5><ul><li><strong>row</strong> - 告诉自动算法轮流填充每一行，如果有需要就添加新行（默认值）</li><li><strong>column</strong> - 告诉自动算法轮流填充每一列，如果有需要就添加新列</li><li><strong>dense</strong> - 告诉自动算法 to attempt to fill in holes earlier in the grid if smaller items come up later</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: row | column | row dense | column dense;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <strong>dense</strong> 只是改变 items 视觉上的顺序，让它们乱序的出现，对易用性来说这是不好的。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-a"</span>&gt;</span>item-a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-b"</span>&gt;</span>item-b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-c"</span>&gt;</span>item-c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-d"</span>&gt;</span>item-d<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-e"</span>&gt;</span>item-e<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义一个两行五列的 grid，设置 <code>grid-auto-flow</code> 为 <code>row</code>（默认值）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 items 放置在 grid 中后，只需要指定其中两个点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-e</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为已经设置了 <code>grid-auto-flow</code> 为 <code>row</code>，所以 grid 将会看起来像这样。要注意其中三个并没有被设置，所以它们沿着可用的行流动。</p><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-auto-flow-row.png" alt="grid-auto-flow"></p><p>如果设置 <code>grid-auto-flow</code> 为 <code>column</code>，那么 <strong>item-b</strong>，<strong>item-c</strong>，<strong>item-d</strong> 就会沿着列流动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-auto-flow-column.png" alt="grid-auto-flow"></p><h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><p>这是一个将 <code>grid-template-rows</code>，<code>grid-template-columns</code>，<code>grid-template-areas</code>，<code>grid-auto-rows</code>，<code>grid-auto-column</code> 和 <code>grid-auto-flow</code> 这些属性简写到一起的属性。（注意：只能对显式或隐式的 grid 使用单独声明来指定属性）</p><h5 id="值：-14"><a href="#值：-14" class="headerlink" title="值："></a>值：</h5><ul><li><strong>none</strong> - 设置所有的子属性为它们的初始值</li><li><strong>&lt;grid-template></strong> - 跟 <code>grid-template</code> 这个简写方式相同</li><li><strong>&lt;grid-template-rows> / [auto-flow &amp;&amp; dense?] &lt;grid-auto-column>?</strong> - 设置 <code>grid-template-rows</code> 为指定的值。如果在斜杠的右边有 <code>auto-flow</code> 关键字，那么它会把 <code>grid-auto-flow</code> 设置为 <code>column</code>。如果还加上了 <code>dense</code> 关键字，那么自动安置算法会使用“密集包装算法（dense packing algorithm）”。如果 <code>grid-auto-column</code> 被省略，它会被设置为 <code>auto</code>。</li><li><strong>[auto-flow &amp;&amp; dense?] &lt;grid-auto-rows>? / &lt;grid-template-columns></strong> - 设置 <code>grid-template-columns</code> 的值。如果 <code>auto-flow</code> 关键字被使用，那么 <code>grid-auto-flow</code> 会被设置为 <code>row</code>。如果还加上了 <code>dense</code> 关键字，那么自动安置算法会使用“密集包装算法（dense packing algorithm）”。如果 <code>grid-auto-rows</code> 被省略，它会被设置为 <code>auto</code>。</li></ul><p>下面两块代码是等价的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid</span>: <span class="number">100px</span> <span class="number">300px</span> / <span class="number">3</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">3</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两块代码是等价的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>: &#123;</span><br><span class="line">    <span class="attribute">grid</span>: auto-flow / <span class="number">200px</span> <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: row;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两块代码是等价的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid</span>: auto-flow dense <span class="number">100px</span> / <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: row dense;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两块代码是等价的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid</span>: <span class="number">100px</span> <span class="number">300px</span> / auto-flow <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也可以使用更复杂但是更方便的语法一次设置好每项。可以指定 <code>grid-template-areas</code>，<code>grid-template-rows</code>，<code>grid-template-columns</code> 然后所有其他的子属性都会被设置为它们的初始值。要做的就是指定 line 名和 track 尺寸以及它们各自的 grid areas。例子如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid</span>: [row1-start] <span class="string">"header header header"</span> <span class="number">1</span>fr [row1-end]</span><br><span class="line">          [row2-start] <span class="string">"footer footer footer"</span> <span class="number">25px</span> [row2-end]</span><br><span class="line">          / auto <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等价于：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: </span><br><span class="line">        <span class="string">"header header header"</span></span><br><span class="line">        <span class="string">"footer footer footer"</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">1</span>fr [row1-end row2-start] <span class="number">25px</span> [row2-end];</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用于-Grid-Items-的属性（即子元素的属性）"><a href="#用于-Grid-Items-的属性（即子元素的属性）" class="headerlink" title="用于 Grid Items 的属性（即子元素的属性）"></a>用于 Grid Items 的属性（即子元素的属性）</h3><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><code>float</code>，<code>display: inline-block</code>，<code>display: table-cell</code>，<code>vertical-align</code> 和 <code>column-*</code> 这些属性对 grid item 没有作用。</p><h4 id="grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="grid-column-start / grid-column-end / grid-row-start / grid-row-end"></a>grid-column-start / grid-column-end / grid-row-start / grid-row-end</h4><p>用于确定在 grid 中的 grid items 相对于指定的 grid lines 的位置。<code>grid-column-start</code> / <code>grid-row-start</code> 是 item 开始的 line，而 <code>grid-column-end</code> / <code>grid-row-end</code> 是 item 结束的 line。</p><h5 id="值：-15"><a href="#值：-15" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;line></strong> - 可以是指代用数字编号的 grid line 的数字，或者是用命名指定的 grid line 的名字</li><li><strong>span &lt;number></strong> - item 会跨越指定数目的 grid tracks</li><li><strong>span &lt;name></strong> - item 会跨越至提供的名字的 line 处</li><li><strong>auto</strong> - 指示自动排列，自动跨越或者默认的一个跨度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">    <span class="attribute">grid-row-end</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: five;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: row1-start;</span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-start-end-a.png" alt="item"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: span col4-start;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row-end</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/11/grid-start-end-b.png" alt="item"></p><p>如果 <code>grid-column-end</code> / <code>grid-row-end</code> 没有被声明，那么 item 会默认跨越 1 个 track。</p><p>items 还可以相互重叠，可以使用 <code>z-index</code> 控制堆叠的顺序。</p><h4 id="grid-column-grid-row"><a href="#grid-column-grid-row" class="headerlink" title="grid-column / grid-row"></a>grid-column / grid-row</h4><p><code>grid-column</code> 是 <code>grid-column-start</code> + <code>grid-column-end</code> 的简写，<code>grid-row</code> 是 <code>grid-row-start</code> + <code>grid-row-end</code> 的简写。</p><h5 id="值：-16"><a href="#值：-16" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;start-line> / &lt;end-line></strong> - 每一个都接受与非简写方式的属性值，包括跨度</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">    <span class="attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">3</span> / span <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: third-line / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-start-end-c.png" alt="item"></p><p>如果没有设置 end line 的值，那么 item 会默认跨越 1 个 track。</p><h4 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h4><p>给 item 命名，然后可以被 <code>grid-template-area</code> 引用。或者这个属性可以被用于更加简写的方式，由四个属性组成：<code>grid-row-start</code> + <code>grid-column-start</code> + <code>grid-row-end</code> + <code>grid-column-end</code>。</p><h5 id="值：-17"><a href="#值：-17" class="headerlink" title="值："></a>值：</h5><ul><li><strong>&lt;name></strong> - 取的名字</li><li><strong>&lt;row-start> / &lt;column-start> / &lt;row-end> / &lt;column-end></strong> - 可以为数字，也可以为具名的 lines</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><p>作为给 item 指派一个名字的方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为以下四个属性的简写方式：<code>grid-row-start</code> + <code>grid-column-start</code> + <code>grid-row-end</code> + <code>grid-column-end</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: <span class="number">1</span> / col4-start / last-line / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-start-end-d.png" alt="item"></p><h4 id="justify-self"><a href="#justify-self" class="headerlink" title="justify-self"></a>justify-self</h4><p>将 cell 中的 grid item 沿着内联轴（row）对齐（与 <code>align-self</code> 相对，<code>align-self</code> 是沿块级轴（column）对齐）。这个属性只对单独一个的 cell 里面的 grid item 生效。</p><h5 id="值：-18"><a href="#值：-18" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 grid item 与 cell 的起始边缘对齐</li><li><strong>end</strong> - 将 grid item 与 cell 的结束边缘对齐</li><li><strong>center</strong> - 将 grid item 在 cell 水平居中对齐</li><li><strong>stretch</strong> - 将 cell 的宽度填满（默认值）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-self-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-self-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-self-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-justify-self-stretch.png" alt="stretch"></p><p>要为 grid 中所有的 items 设置水平对齐方式，使用 <code>justify-items</code> 对 grid container（父元素）进行设置。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>将 cell 中的 grid item 沿着块级轴（column）对齐（与 <code>justify-self</code> 相对，<code>justify-self</code> 是沿内联轴（row）对齐）。这个属性只对单独一个的 cell 里面的 grid item 生效。</p><h5 id="值：-19"><a href="#值：-19" class="headerlink" title="值："></a>值：</h5><ul><li><strong>start</strong> - 将 grid item 与 cell 的起始边缘对齐</li><li><strong>end</strong> - 将 grid item 与 cell 的结束边缘对齐</li><li><strong>center</strong> - 将 grid item 在 cell 水平居中对齐</li><li><strong>stretch</strong> - 将 cell 的宽度填满（默认值）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-self-start.png" alt="start"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-self-end.png" alt="end"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-self-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-self-stretch.png" alt="stretch"></p><p>要为 grid 中所有的 items 设置垂直对齐方式，使用 <code>align-items</code> 对 grid container（父元素）进行设置。</p><h4 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h4><p>是同时设置 <code>align-self</code> 和 <code>justify-self</code> 属性的简写方式。</p><h5 id="值：-20"><a href="#值：-20" class="headerlink" title="值："></a>值：</h5><ul><li><strong>auto</strong> - 布局模式中的“默认”对齐方式</li><li><strong>&lt;align-self> / &lt;justify-self></strong> - 第一个值设置 <code>align-self</code>，第二个值设置 <code>justify-self</code>。如果第二个值被忽略，那么第一个值，同时作用于两个属性。</li></ul><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">place-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2018/04/grid-place-self-center.png" alt="center"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">    <span class="attribute">place-self</span>: center stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/grid-align-self-center.png" alt="center stretch"></p><p>除 Edge 之外的所有主流浏览器都支持 <code>place-self</code> 这个简写属性。</p><h2 id="支持的动画效果"><a href="#支持的动画效果" class="headerlink" title="支持的动画效果"></a>支持的动画效果</h2><p>参照 CSS Grid Layout Module Level 1 的规范，gird 属性中有 5 项是支持动画效果的：</p><ul><li><code>grid-gap</code>，<code>grid-row-gap</code>，<code>grid-column-gap</code> 为长度，百分比，或 calc（计算值？）的时候</li><li><code>grid-template-columns</code>，<code>grid-template-rows</code> 作为简单列表时的长度，百分比或者 calc（计算值？）的时候，而且区别之处只有列表里面的长度，百分比或者 calc（计算值？）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">A Complete Guide to Grid - css-tricks.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Grid 布局是 CSS 中最强大的布局方式。它是一个二维系统，也就是说，它能同时处理行和列，而不像 &lt;code&gt;flexbox&lt;/code&gt; 这样是一个一维系统。使用 Grid 布局方式可以同时将 CSS 规则作用于父元素（成为 Grid Container）和子元素（成
      
    
    </summary>
    
    
      <category term="css" scheme="http://zhcexo.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox 完全指南</title>
    <link href="http://zhcexo.com/2018/07/16/a-complete-guide-to-flexbox/"/>
    <id>http://zhcexo.com/2018/07/16/a-complete-guide-to-flexbox/</id>
    <published>2018-07-16T07:32:48.000Z</published>
    <updated>2019-03-19T02:16:49.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Flexbox Layout (Flexible Box) 模式用于提供一个更有效率的布局途径，让容器(container) 中的子元素(items) 在尺寸未知或者动态变化的时候，也能对齐和分配项目之间的空白，因为称作 flex (弹性)。</p><p>Flex 布局的主要思想是让容器能够改变里面项目的宽度/高度(或者顺序)，以便用最佳方式填充可用空间(大多用来适应各种不同的设备和屏幕尺寸)。flex 容器能让里面的子元素展示以适应可用空间，或者让它们收缩以防止溢出。</p><p>更重要的是，flexbox 的布局方式与常规布局(比如 block 就是基于垂直方向的，而 inline 是基于水平方向的)相比是方向无关的。虽然常规布局对页面来说可以做得很好，但它们缺乏灵活性去适应大型 APP 或复杂的 APP (特别当方向改变，窗口缩放，窗口拉伸，收缩等等)。</p><p><strong>注意：</strong> Flexbox 布局方式适合的是组件化的、小型的布局，如果是大型的布局，<a href="http://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">Grid 布局</a>更为适合。</p><h2 id="基础知识和相关术语"><a href="#基础知识和相关术语" class="headerlink" title="基础知识和相关术语"></a>基础知识和相关术语</h2><p>Flexbox 是一个完整的模式，而不是一个单独的属性，所以它包含了整套的属性。这些属性有的是设置到容器上的(父级元素，也就是 flex container)，有的是设置到子元素上的(子元素，也就是 flex items)。</p><p>如果说常规的布局是基于 block 和 inline 的流动方向，那么 flex 布局基于的就是 flex 的流动方向。下图指明了 flex 布局的规范。</p><p><img src="http://cdn.css-tricks.com/wp-content/uploads/2011/08/flexbox.png" alt="specification"></p><p>通常的，项目元素会基于主轴(从 main-start 到 main-end)或者交叉轴(从 cross-start 到 cross-end)陈列。</p><ul><li><strong>main axis 主轴</strong> - 主轴是 flex 容器里面的子元素陈列的基础轴，它不一定是水平方向的，它的方向依赖于 <code>flex-direction</code> 属性决定</li><li><strong>main-start | main-end</strong> - flex 子元素会依照 main-start 到 main-end 的方向来陈列</li><li><strong>main size</strong> - 一个 flex 元素的宽度或高度，取决于主轴方向，这两个值中的一个，就是 main size。flex 元素的 main size 属性是 <code>width</code> 或者 <code>height</code> 中的一个</li><li><strong>cross axis</strong> 交叉轴 - 垂直于主轴，它的方向取决于主轴的方向</li><li><strong>cross-start | cross-end</strong> - 容器的 flex 行里面填充的子元素，也会按照 cross-start 向着 cross-end 的方向摆放</li><li><strong>cross size</strong> - 一个 flex 子元素的宽度或高度，在交叉轴方向上，两个值中的一个</li></ul><h2 id="父级容器的属性-flex-container"><a href="#父级容器的属性-flex-container" class="headerlink" title="父级容器的属性(flex container)"></a>父级容器的属性(flex container)</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>用来定义一个 flex 容器，inline 级还是 block 级别取决于设置的值。它为 flex 容器的直接子元素定义了 flex 上下文。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; <span class="comment">/* or inline-flex */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><img src="http://css-tricks.com/wp-content/uploads/2013/04/flex-direction2.svg" alt="flex-direction"></p><p>这个属性确定主轴的方向，定义了子元素在父容器中的陈列。Flexbox 是一种单向布局理念，flex 子元素基本都是以水平行或者垂直列的方式呈现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>row</code> (默认值)：在 <code>ltr</code> 语言中是从左到右，<code>rtl</code> 语言中是从右到左</li><li><code>row-reverse</code>： 在 <code>ltr</code> 语言中是从右到左，<code>rtl</code> 语言中是从左到右</li><li><code>column</code>：跟 <code>row</code> 相同，但是是从上到下</li><li><code>column-reverse</code>：跟 <code>row-reverse</code> 相同，但是是从下到上</li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><img src="http://css-tricks.com/wp-content/uploads/2014/05/flex-wrap.svg" alt="flex-wrap"></p><p>默认的，flex 子元素会试着呈现在一行里面，改变这个值可以让子元素按需折行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>nowrap</code> (默认值)：所有的 flex 子元素都位于一行</li><li><code>wrap</code>：所有的 flex 子元素可以换行陈列于若干行，从上至下</li><li><code>wrap-reverse</code>：所有的 flex 子元素可以换行陈列于若干行，从下至上</li></ul><h3 id="flex-flow-给-flex-容器设置-flex-direction-和-flex-wrap-的缩写"><a href="#flex-flow-给-flex-容器设置-flex-direction-和-flex-wrap-的缩写" class="headerlink" title="flex-flow (给 flex 容器设置 flex-direction 和 flex-wrap 的缩写)"></a>flex-flow (给 flex 容器设置 flex-direction 和 flex-wrap 的缩写)</h3><p>这只是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的缩写方法而已，用于同时定义父容器的主轴交叉轴和是否折行，默认值是 <code>row nowrap</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;'flex-direction'&gt; || &lt;'flex-wrap'&gt;</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><img src="http://cdn.css-tricks.com/wp-content/uploads/2013/04/justify-content-2.svg" alt="justify-content"></p><p>此属性用于定义主轴的对齐方式。它用于分配剩余的空白空间(It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size.)。同时它也能控制子元素在超过一行时的对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.containter</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code> (默认值)：子元素从起始处开始呈现</li><li><code>flex-end</code>：子元素从末尾开始呈现</li><li><code>center</code>：子元素中间对齐</li><li><code>space-between</code>： 子元素均匀分布于行内，首元素位于行起始</li><li><code>space-around</code>：子元素及其周围空间都会均匀分布。值得注意的是，视觉上空白并不均匀，因为所有子元素都有两个边缘。首元素与父容器的边缘有一单位的空白，但与下一个子元素的边缘有两个单位的空白(也就是上一个元素的右空白与下一个元素的左空白叠加在一起)</li><li><code>space-evenly</code>：子元素均匀分布，每两个子元素之间的空白都是相等的</li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><img src="http://cdn.css-tricks.com/wp-content/uploads/2014/05/align-items.svg" alt="align-items"></p><p>用来定义 flex 子元素在交叉轴方向上，默认的陈列方式。可以看作是 <code>justify-content</code> 在交叉轴上的版本。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>：从 cross-start 的起始边缘开始呈现</li><li><code>flex-end</code>： 从 cross-end 的结束边缘开始呈现</li><li><code>center</code>：子元素垂直居中于交叉轴</li><li><code>baseline</code>：子元素按它们的 baseline 对齐</li><li><code>stretch</code> (默认值)：拉伸以填满容器(同时受到 min-width / max-width 的影响)</li></ul><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><img src="http://css-tricks.com/wp-content/uploads/2013/04/align-content.svg" alt="algin-content"></p><p>这个属性用于处理 flex 容器内行与行之间、在交叉轴上有多余空间时的对齐问题，如同 <code>justify-content</code> 在主轴上对子元素对齐的处理。</p><p><strong>注意：</strong> 这个属性在 flex 子元素只有一行的情况下是不生效的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>：行从父容器起始处呈现</li><li><code>flex-end</code>：行从父容器结束处呈现</li><li><code>center</code>：行与父容器中间对齐</li><li><code>space-between</code>：行之间均匀分布，第一行处于父容器起始，最后一行处理父容器结束处</li><li><code>space-around</code>：行之间均匀分布，并且每行的空白也是平均的</li><li><code>stretch</code> (默认值)：每行伸展以占据空白区域</li></ul><h2 id="子元素的属性-flex-items"><a href="#子元素的属性-flex-items" class="headerlink" title="子元素的属性(flex items)"></a>子元素的属性(flex items)</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><img src="http://css-tricks.com/wp-content/uploads/2013/04/order-2.svg" alt="order"></p><p>默认的，flex 子元素是按源码里的顺序来排列的。然而 <code>order</code> 属性可以控制它们在父容器中出现的顺序。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default is 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><img src="http://css-tricks.com/wp-content/uploads/2014/05/flex-grow.svg" alt="flex-grow"></p><p>这个属性定义的是 flex 子元素按需增长的能力。它接受的值是无单的数字作为比例，它规定了子元素占据 flex 父容器内可用空间的量。</p><p>如果所有的子元素都把 <code>flex-grow</code> 设置为 1，那么父容器中剩余的空间将会平分给每一个子元素。如果其中一个子元素的值设置为 2，那么它将占据其他子元素 2 倍的空间 (或者试图占据 2 倍)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负数的值是非法的。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>这个属性定义的是 flex 子元素按需收缩的能力。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负数的值是非法的。</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>它定义的是子元素在分配到剩余空间之前的元素的默认尺寸。它的值可以是长度 (例如：20%，5rem 等等) 或者是关键字。<code>auto</code> 这个关键字意义是“参照宽度 width 或者高度 height 属性” (这是由 <code>main-size</code> 关键字暂代实现，直到被弃用为止)。<code>content</code> 这个关键字意义是“尺寸由子元素的内容来决定” - 这个关键字并没有被很好的支持，所以也不好测试，更不知道是 <code>max-content</code>、<code>min-content</code> 或 <code>fit-content</code> 中的哪个起的作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被设置为 0，那么内容周围的多余空白就没被考虑进去，如果设置为 <code>auto</code>，那么多余空白的分布，取决于它的 <code>flex-grow</code> 值。见下图：</p><p><img src="http://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" alt="flex-basis"></p><blockquote><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p></blockquote><blockquote><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p></blockquote><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>这个属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 三个属性的简写方式，其中第二和第三个参数(也就是 <code>flex-shrink</code> 和 <code>flex-basis</code>)是可选的。默认值是 <code>0 1 auto</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用这个缩写的属性</strong> 而不是单独设置各种属性的值。因为缩写方法会智能地设置其他值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><img src="http://css-tricks.com/wp-content/uploads/2014/05/align-self.svg" alt="align-self"></p><p>这个属性允许单个的 flex 子元素的默认的对齐(或者被 <code>align-item</code> 声明过)被覆盖。</p><p>参看 <code>align-items</code> 解释，看可设置的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 对 flex 子元素无影响。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox - css-tricks.com</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;p&gt;Flexbox Layout (Flexible Box) 模式用于提供一个更有效率的布局途径，让容器(container)
      
    
    </summary>
    
    
      <category term="css" scheme="http://zhcexo.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>更新Ubuntu以及更新SS以支持新的加密方法</title>
    <link href="http://zhcexo.com/2018/07/06/ubuntu-update-and-ss-update/"/>
    <id>http://zhcexo.com/2018/07/06/ubuntu-update-and-ss-update/</id>
    <published>2018-07-06T02:48:19.000Z</published>
    <updated>2018-07-06T03:21:19.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>每次用 SSH 的方式登入服务器的时候，都会提示如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Ubuntu *.*.* LTS (GNU/Linux *.*.*-*-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line"></span><br><span class="line"> ……</span><br><span class="line"></span><br><span class="line">13 packages can be updated.</span><br><span class="line">10 updates are security updates.</span><br></pre></td></tr></table></figure><p>字面提示是有 13 个包可以升级，其中 10 个是安全更新。</p><p>事实上 Ubuntu 更新还是挺容易的，因为有 <code>apt-get</code>，不过更新完之后，还是会提示一些安全更新没做完，所以找了一下解决方案。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h4 id="命令说明："><a href="#命令说明：" class="headerlink" title="命令说明："></a>命令说明：</h4><ul><li><code>apt-get update</code> 从服务器更新可用的软件包<strong>列表</strong>。</li><li><code>apt-get upgrade</code> 根据列表，更新已安装的软件包。这个命令<strong>不会</strong>删除在列表中已经没有的软件包，<strong>也不会</strong>安装有依赖需求但尚未安装的软件包。</li><li><code>apt-get dist-upgrade</code> 根据列表，更新已安装的软件包。这个命令可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。</li></ul><p>所以使用上面三个命令完成更新之后，用 <code>reboot</code> 命令重启系统就行。<strong>需要注意的是，以上所有命令都需要在 root 权限下执行。</strong></p><p>更新完成之后，去启动 SS，然后就报错了，从没见过的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load libsodium failed with path None</span><br></pre></td></tr></table></figure><p>不清楚是更新的系统造成的，还是其他原因，反正 SS 不能用了。搜索了一下，发现用这个 lib 的话，SS 可以支持新的高效率一点的加密方式 <code>chacha20</code> 等等这些。</p><p>于是乎，装一下 <code>libsodium</code> 吧~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar xf LATEST.tar.gz &amp;&amp; cd libsodium-*.*.*</span><br><span class="line">./configure &amp;&amp; make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完毕之后，修改 SS 配置文件，把加密换成 <code>chacha20-ietf-poly1305</code>，启动 SS，没有任何报错，一切正常。</p><p>客户端也把加密方式修改成相应的，完成~~</p><h4 id="不用自己编译的安装方式（未验证）"><a href="#不用自己编译的安装方式（未验证）" class="headerlink" title="不用自己编译的安装方式（未验证）"></a>不用自己编译的安装方式（未验证）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:chris-lea/libsodium</span><br><span class="line">echo "deb http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo "deb-src http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main" &gt;&gt; /etc/apt/sources.list</span><br><span class="line">apt-get update &amp;&amp; apt-get install libsodium-dev</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ul><li><a href="https://liam0205.me/2015/06/27/ubuntu-server-packages-can-be-updated/" target="_blank" rel="noopener">升级 Ubuntu，解决登录时提示有软件包可以更新的问题</a></li><li><a href="https://blog.csdn.net/lengconglin/article/details/77655845" target="_blank" rel="noopener">Linux下安装libsodium,启用ss的chacha20高级加密</a></li><li><a href="https://gist.github.com/jonathanpmartins/2510f38abee1e65c6d92" target="_blank" rel="noopener">Install Libsodium on Ubuntu 14.04.3 LTS Trusty</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;每次用 SSH 的方式登入服务器的时候，都会提示如下信息：&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>让HTML Webpack Plugin根据多entry把html文件生成到指定目录中</title>
    <link href="http://zhcexo.com/2018/06/16/html-webpack-plugin-multiple-entries/"/>
    <id>http://zhcexo.com/2018/06/16/html-webpack-plugin-multiple-entries/</id>
    <published>2018-06-16T14:13:40.000Z</published>
    <updated>2018-07-06T03:23:53.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>项目里有需要处理一堆目录的 html 文件自动生成，并且生成到相应的目录中。与 html 文件相对应的样式 css 文件和脚本 js 文件，也要放到相应的目录中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">目录结构如下：</span><br><span class="line">- dist</span><br><span class="line">- src</span><br><span class="line">    |- a</span><br><span class="line">        `- index.js</span><br><span class="line">    |- b</span><br><span class="line">        `- index.js</span><br><span class="line">    |- c</span><br><span class="line">        `- index.js</span><br><span class="line">    `- tpl</span><br><span class="line">        `- index.html</span><br><span class="line">    </span><br><span class="line">希望得到的结果是，a，b，c 三个目录中的 index.js 都是入口文件，以 tpl 中的 index.html 为模板，</span><br><span class="line">经由 webpack 打包之后，在 dist 目录中生成 a，b，c 三个目录，</span><br><span class="line">并且每个目录中都存在 html，css，js 三个目录，里面存放相应生成的文件。</span><br><span class="line">生成如下的目录结构：</span><br><span class="line">- dist</span><br><span class="line">    |- a</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">    |- b</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">    `- c</span><br><span class="line">        |- css</span><br><span class="line">        |- html</span><br><span class="line">        `- js</span><br><span class="line">- src</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>说到自动生成 html 文件，第一想法就是 <code>HtmlWebpackPlugin</code>，但是这个插件不支持 webpack 中类似于 <code>[name]</code> 这样的命名，所以想用 <code>[name]</code> 这样的命名方式变向成生文件夹的方法是行不通的。另外，每个条 <code>new HtmlWebpackPlugin()</code> 语句，只能生成一个页面，像我这样要大批量生成文件，是不太方便的。</p><p>因为要做到生成的文件，有对应的目录，所以在配置 webpack 的 entry 的时候，可以使用多入口方式。</p><p>大体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries: &#123;</span><br><span class="line">    a: <span class="string">'./a'</span>,</span><br><span class="line">    b: <span class="string">'./b'</span>,</span><br><span class="line">    c: <span class="string">'./c'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> entryHtmlPlugins = <span class="built_in">Object</span>.keys(entries).map(<span class="function"><span class="keyword">function</span>(<span class="params">entryName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        filename: entryName + <span class="string">'.html'</span>,</span><br><span class="line">        chunks: [entryName]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry: entries,</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">plugins: [</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">].concat(entryHtmlPlugins)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">HTML Webpack Plugin</a><br><a href="https://github.com/jantimon/html-webpack-plugin/issues/299" target="_blank" rel="noopener">Support multiple Webpack entries</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;项目里有需要处理一堆目录的 html 文件自动生成，并且生成到相应的目录中。与 html 文件相对应的样式 css 
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://zhcexo.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中为切片 append 元素之后 cap 变化的问题</title>
    <link href="http://zhcexo.com/2018/05/25/append-and-cap-in-golang/"/>
    <id>http://zhcexo.com/2018/05/25/append-and-cap-in-golang/</id>
    <published>2018-05-25T06:04:04.000Z</published>
    <updated>2018-05-25T06:29:39.034Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 Go 语言基础的时候，看到了 slice 切片这里，里面有个 append 方法，用于往 slice 里添加元素。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line"></span><br><span class="line">    numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]</span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure><p>差一点就看看跳过了，不过最后一行的结果，<code>cap</code> 执行的结果显示，这个 <code>numbers</code> 切片的容量为 6。</p><p>如果是写其他的语言，比如 JavaScript，那么这个结果可能会跟 <code>length</code> 作类比从而产生“为什么容量不是 5”这种想法，毕竟我们只在 slice 里添加了 5 个元素。翻了一下官方的文档也没有解释，后来在 stackoverflow 上看到了别人的回答，大致总结如下：</p><blockquote><p>Go 会为你的 slice 提供比你需要的更多的容量，原因是在 slice 的底层，有个不可变动的（immutable）数组（array）在实际起作用。当你要为 slice 添加元素从而让切片的容量更大的时候，实际上是创建了一个新数组，把原来的切片元素和新添加的元素放到新的数组里，并把这个数组作为新 slice 的底层。如果你添加很多数据到 slice 里，就会反复去创建和复制这些数据，影响性能。所以运行时会分配比你期望的更多的容量到 slice，让复制数据这些操作变得不那么频繁。</p></blockquote><p>虽然原因找下来，感觉这个问题似乎不怎么重要，不过有人如果看到这里，跟我有同样的疑惑，也可以做个参照。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://stackoverflow.com/questions/38573983/capacity-of-slices-in-go" target="_blank" rel="noopener">https://stackoverflow.com/questions/38573983/capacity-of-slices-in-go</a></li><li><a href="https://stackoverflow.com/questions/38543825/appending-one-element-to-nil-slice-increases-capacity-by-two" target="_blank" rel="noopener">https://stackoverflow.com/questions/38543825/appending-one-element-to-nil-slice-increases-capacity-by-two</a></li><li><a href="https://blog.csdn.net/a_flying_bird/article/details/54428546" target="_blank" rel="noopener">Go-append使用方法及注意事项</a></li><li><a href="https://blog.csdn.net/zxhoo/article/details/70159926" target="_blank" rel="noopener">Go语言小知识之append()函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习 Go 语言基础的时候，看到了 slice 切片这里，里面有个 append 方法，用于往 slice 里添加元素。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="go" scheme="http://zhcexo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>记一次搭梯子的过程</title>
    <link href="http://zhcexo.com/2018/05/24/ladder/"/>
    <id>http://zhcexo.com/2018/05/24/ladder/</id>
    <published>2018-05-24T09:21:32.000Z</published>
    <updated>2018-05-24T09:54:42.402Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直用的 Japan 的线路，结果越来越不稳定，后来干脆变成不可用了，所以换了一家 VPS 换了一条线路，以此文章记录一下这次的过程，方便以后折腾。</p><p>服务器安装的是 <strong>ubuntu 18 LTS x64 版本</strong>，准备使用 55 和 kcp 当梯子。</p><h2 id="步骤：-以下步骤默认都是-root-下执行"><a href="#步骤：-以下步骤默认都是-root-下执行" class="headerlink" title="步骤：(以下步骤默认都是 root 下执行)"></a>步骤：(以下步骤默认都是 root 下执行)</h2><h3 id="1-安装-python-pip-和-55"><a href="#1-安装-python-pip-和-55" class="headerlink" title="1. 安装 python-pip 和 55"></a>1. 安装 python-pip 和 55</h3><p>使用两个命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><p>执行第二个命令如果报错，例如 <code>ImportError: No module named setuptools</code>，只需要再安装 setuptools 即可。</p><p>先查看自己服务器的 Python 版本：</p><blockquote><ol><li>在终端上输入 python，进入 python shell</li><li>输入 help() 查看 python 版本</li><li>查看完毕后，输入 exit() 退出 python shell</li></ol></blockquote><p>接下来安装 setuptools：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python3.4</span><br></pre></td></tr></table></figure><h3 id="2-配置和启用-55"><a href="#2-配置和启用-55" class="headerlink" title="2. 配置和启用 55"></a>2. 配置和启用 55</h3><p>安装完之后，在 <code>/etc/</code> 目录下创建配置文件，命名为 <code>shadowsocks.json</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,             <span class="comment">// your server ip goes here</span></span><br><span class="line">    <span class="string">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"**********"</span>,        <span class="comment">// your ss password goes here</span></span><br><span class="line">    <span class="string">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-gcm"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动和停止 55 的方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start      # 这是后台启动的方式</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop       # 这是对应的停止的方式</span><br></pre></td></tr></table></figure><h3 id="3-安装-kcptun"><a href="#3-安装-kcptun" class="headerlink" title="3. 安装 kcptun"></a>3. 安装 kcptun</h3><p>直接访问项目地址吧，安装过程不说了，<a href="https://github.com/kuoruan/shell-scripts" target="_blank" rel="noopener">https://github.com/kuoruan/shell-scripts</a>。</p><p>安装过程中可能会提示 <code>iptables</code> 相关的错误，原因是 <code>iptables</code> 在 centos 和 ubuntu 上有差异。脚本似乎是针对 centos 写的，不过无所谓，脚本里面已经提示了自己去解决 <code>iptables</code> 问题，但直接按提示去解决会出错。</p><p>解决办法无外乎两步：首先添加相应规则到 <code>iptables</code>，然后重启 <code>iptables</code> 服务。</p><p>添加 <code>iptables</code> 配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p udp --dport 29900 -j ACCEPT        # 29900 换成你自己的</span><br></pre></td></tr></table></figure></p><p>保存 <code>iptables</code> 的配置（ubuntu 下）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save</span><br></pre></td></tr></table></figure></p><p>重启 <code>iptables</code>，因为 ubuntu 用的是 <code>ufw</code> 作为 <code>iptables</code> 的前端，所以使用如下命令重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ufw restart</span><br></pre></td></tr></table></figure></p><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><p>在配置 kcptun 的时候，加速的 IP 填写外网的 IP，如果填本地 IP（127.0.0.1 或者 0.0.0.0）都会出来 <code>dial tcp 127.0.0.1:8388: connect: connection refused</code> 这种错误。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><p><a href="https://blog.kuoruan.com/110.html" target="_blank" rel="noopener">https://blog.kuoruan.com/110.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直用的 Japan 的线路，结果越来越不稳定，后来干脆变成不可用了，所以换了一家 VPS 换了一条线路，以此文章记录一下这次的过程，方便以后折腾。&lt;/p&gt;
&lt;p&gt;服务器安装的是 &lt;strong&gt;ubuntu 18 LTS x64 版本&lt;/strong&gt;，准备使用 55
      
    
    </summary>
    
    
      <category term="server" scheme="http://zhcexo.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>在 VSCODE 中安装 Go 语言相关支持</title>
    <link href="http://zhcexo.com/2018/05/21/go-tools-in-vscode/"/>
    <id>http://zhcexo.com/2018/05/21/go-tools-in-vscode/</id>
    <published>2018-05-21T01:58:03.000Z</published>
    <updated>2018-05-21T02:11:44.133Z</updated>
    
    <content type="html"><![CDATA[<p>写好 Go 文件，用 VSCode 打开之后，右下角会提示缺少 Go 相关的支持，然后会有两个按钮 <code>Install</code> 和 <code>Show</code>。<code>Install</code> 是自动安装这些支持，<code>Show</code> 是显示缺了些什么。但实际情况是，点了 <code>Install</code> 之后，控制台一堆报错并且安装失败。</p><p>点击 <code>Install</code> 或者 <code>Show</code>，控制台里已经显示缺少如下工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">github.com/ramya-rao-a/go-outline</span><br><span class="line">github.com/acroca/go-symbols</span><br><span class="line">golang.org/x/tools/cmd/guru</span><br><span class="line">golang.org/x/tools/cmd/gorename</span><br><span class="line">github.com/rogpeppe/godef</span><br><span class="line">github.com/sqs/goreturns</span><br><span class="line">github.com/golang/lint/golint</span><br><span class="line">github.com/derekparker/delve/cmd/dlv</span><br></pre></td></tr></table></figure><p>然后用 <code>go install</code> 或者 <code>go get -v</code> 都安装不成功。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>打开 Go 的安装目录</li><li>进入安装目录下的 <code>src</code> 目录，新建 <code>golang.org</code> 目录，在此目录下继续新建 <code>x</code> 目录</li><li>进入 <code>安装目录/golang.org/x</code> 目录，执行以下两个命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/golang/tools.git</span><br><span class="line">git clone https://github.com/golang/lint.git</span><br></pre></td></tr></table></figure><p>第一个安装除 <code>go-lint</code> 之外其他工具的支持，第二个安装 <code>go-lint</code> 支持。</p><p>以上步骤都处理完之后，就可以用 <code>go get ***</code> 和 <code>go install ***</code> 这种方式把缺的工具都装好。安装之后重启 VScode 即使用 Go 语言相关支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写好 Go 文件，用 VSCode 打开之后，右下角会提示缺少 Go 相关的支持，然后会有两个按钮 &lt;code&gt;Install&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt;。&lt;code&gt;Install&lt;/code&gt; 是自动安装这些支持，&lt;code&gt;Show&lt;/cod
      
    
    </summary>
    
    
      <category term="go" scheme="http://zhcexo.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>同一页面运行wepback不同实例出现冲突的解决办法</title>
    <link href="http://zhcexo.com/2018/04/18/webpack-multiple-instance-on-the-same-page/"/>
    <id>http://zhcexo.com/2018/04/18/webpack-multiple-instance-on-the-same-page/</id>
    <published>2018-04-18T03:03:00.000Z</published>
    <updated>2018-07-06T03:23:53.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>对于同一个页面功能由不同的同事开发，都用到了 <code>webpack</code> 以及 <code>CommonsChunkPlugin</code>，最后把打包出来的代码，整合到一起的时候，冲突了。</p><h3 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h3><p>各自用 <code>webpack</code> 打包代码没有问题，但是加载到页面上时，代码报错且错误难以定位。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在 <code>webpack</code> 的配置选项里使用 <code>output.jsonpFunction</code>。</p><p>看一下文档里说的：</p><blockquote><p>output.jsonpFunction<br><code>string</code><br>仅用在输出目标为 web，且使用 jsonp 的方式按需加载代码块时。<br>一个命名的 JSONP 函数用于异步加载代码块或者把多个初始化代码块合并到一起时使用（如 CommonsChunkPlugin, AggressiveSplittingPlugin）。<br>当同一个页面上有多个 webpack 实例（源于不同的编译），需要修改这个函数名。<br>如果使用了 <code>output.library</code> 选项，那么这个 <code>library</code> 的命名会自动附加上。</p></blockquote><p>事实上 webpack 并不在全局命名空间下运行，但是 <code>CommonsChunkPlugin</code> 这样的插件会使用异步 JSONP 的方法按需加载代码块。插件会注册一个全局的函数叫 <code>window.webpackJsonp</code>，所以同一个页面上运行多个源自不同 webpack 打包出来的代码时，可能会引起冲突。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://webpack.js.org/configuration/output/#output-jsonpfunction" target="_blank" rel="noopener">webpack - configuration - output - jsonpfunction</a></p><p><a href="https://medium.com/@cliffers/how-to-run-multiple-webpack-instances-on-the-same-page-and-avoid-any-conflicts-4e2fe0f016d1" target="_blank" rel="noopener">How to run multiple webpack instances on the same page…and avoid any conflicts</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h3&gt;&lt;p&gt;对于同一个页面功能由不同的同事开发，都用到了 &lt;code&gt;webpack&lt;/code&gt; 以及 &lt;code&gt;Commo
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://zhcexo.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>常用 git 命令备忘</title>
    <link href="http://zhcexo.com/2018/03/23/git-cheat-sheet/"/>
    <id>http://zhcexo.com/2018/03/23/git-cheat-sheet/</id>
    <published>2018-03-23T03:02:43.000Z</published>
    <updated>2018-03-23T03:10:47.348Z</updated>
    
    <content type="html"><![CDATA[<p>导出项目文件</p><p><code>git archive --format zip -o filename.zip HEAD</code></p><p>修剪远程分支</p><p><code>git remote prune origin</code></p><p>显示本地分支与远程分支跟踪关系</p><p><code>git branch -vv</code></p><p>重命名本地分支</p><p><code>git branch -m oldname newname</code></p><p>本地分支与远程分支建立关系</p><p><code>git branch --set-upstream-to=origin/&lt;branch&gt; &lt;cur branch&gt;</code></p><p>强制覆盖本地文件的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git reset --hard origin/master 或</span><br><span class="line">git reset --hard origin/develop 依此类推，使用想用的分支</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导出项目文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git archive --format zip -o filename.zip HEAD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修剪远程分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote prune origin&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="git" scheme="http://zhcexo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>在 PhpStorm 中集成 git bash</title>
    <link href="http://zhcexo.com/2018/03/22/phpstorm-with-git-bash/"/>
    <id>http://zhcexo.com/2018/03/22/phpstorm-with-git-bash/</id>
    <published>2018-03-22T10:12:34.000Z</published>
    <updated>2018-03-23T03:33:09.173Z</updated>
    
    <content type="html"><![CDATA[<p>直接看图，注意后面的参数 <code>-login -i</code> 不能反了。</p><p><img src="http://of723n9da.bkt.clouddn.com/2016-10-17_220547.jpg" alt="git bash in phpstorm"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接看图，注意后面的参数 &lt;code&gt;-login -i&lt;/code&gt; 不能反了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://of723n9da.bkt.clouddn.com/2016-10-17_220547.jpg&quot; alt=&quot;git bash in phpst
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://zhcexo.com/tags/Tools/"/>
    
  </entry>
  
</feed>
